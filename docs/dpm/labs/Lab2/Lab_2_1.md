# Вызов методов из библиотеки классов .NET с помощью C#.

Язык программирования C# дополнен большой библиотекой функциональных возможностей, позволяющей создавать приложения, получать доступ к данным в файлах или в Интернете, выполнять сложные математические операции и многое другое. Понимание того, как ориентироваться в этой функциональной библиотеке, является важнейшим навыком, который поможет вам быстрее создавать многофункциональные приложения.

Предположим, вам нужно сформировать ежедневный отчет, основанный на тысячах файлов данных. Чтобы сэкономить время, ваш код использует случайную выборку файлов данных для расчета приблизительного результата, не анализируя все файлы данных. Как можно сгенерировать случайное число? Поддерживается ли это в C#? Если да, то как написать код, чтобы задать диапазон значений для случайного числа, а затем сгенерировать и получить результат?

В этом модуле вы узнаете о библиотеках классов и напишете код, вызывающий методы из библиотеки классов .NET. Вы узнаете о характеристиках методов и о том, почему методы библиотеки классов .NET разработаны и реализованы по-разному в разных библиотеках классов .NET. И самое главное, вы напишете код, который использует методы библиотеки .NET для решения конкретной задачи программирования. Наконец, вы будете использовать встроенные инструменты и онлайн-документацию для сбора информации о методах, с которыми хотите работать.

К концу этого модуля вы будете знать, как находить классы и методы в библиотеке классов .NET и как использовать их для выполнения общих задач программирования.

## Цели обучения
В этом модуле вы научитесь:

- Писать код, вызывающий методы из библиотеки классов .NET.

- Использовать экземпляр классов библиотеки классов .NET для вызова методов, поддерживающих состояние.

- Использовать Intellisense в Visual Studio, чтобы узнать больше о методе, включая его перегруженные версии, тип возвращаемого значения и типы данных входных параметров.

- Используйте сайт learn.microsoft.com, чтобы узнать, что делает метод, его перегруженные версии, тип возвращаемого значения, входные параметры и что представляет собой каждый параметр, и многое другое.

## Начало работы с библиотеками .NET

Создание приложения на C# - это не просто набор строк кода. Вам понадобится среда выполнения .NET Runtime, которая размещает и управляет вашим кодом во время его выполнения на компьютере конечного пользователя. Кроме того, вам понадобится библиотека классов .NET - заранее написанная коллекция ресурсов для кодирования, которые вы можете использовать в своих приложениях. В этом разделе рассказывается о том, что такое библиотека классов .NET и как она дополняет язык программирования C#.

### Что такое библиотека классов .NET?
Когда вам нужно найти книгу, лучше всего обратиться в публичную библиотеку. Ведь в библиотеках хранятся тысячи и тысячи книг, и они организованы по разделам, которые помогут вам найти то, что вы ищете. Когда вам нужно реализовать задачу программирования, библиотека классов .NET - хорошее место для поиска, потому что это организованная коллекция ресурсов для программирования.

Библиотека классов .NET - это собрание тысяч классов, содержащих десятки тысяч методов. Например, в библиотеку классов .NET входит класс Console для разработчиков, работающих с консольными приложениями. Класс Console включает методы для операций ввода и вывода, такие как Write(), WriteLine(), Read(), ReadLine() и многие другие. Например, вы уже знакомы со следующим кодом:
```cs
Console.WriteLine("Hello, World!")
```
Класс можно рассматривать как контейнер для методов, наподобие разделов публичной библиотеки. Разработчики обычно объединяют связанные методы в один класс. Как вы видели в предыдущем примере, все методы, которые могут отправлять или получать информацию из консольного окна, собраны в классе System.Console в библиотеке классов .NET.

Во многих случаях эти классы и методы позволяют создавать приложения определенного типа. Например, одно из больших подмножеств классов и методов позволяет создавать динамические веб-приложения. Также есть несколько семейств классов, которые позволяют создавать нативные настольные приложения. Еще одно подмножество классов и методов позволяет обращаться к базе данных. В библиотеке классов .NET есть множество классов, которые поддерживают определенные типы приложений.

Существуют и другие классы с методами, обеспечивающими более общую поддержку. Другими словами, их полезность охватывает широкий спектр платформ устройств, платформ приложений и областей технологий. Например, если вы хотите прочитать или записать информацию о файле или выполнить тригонометрические или вычислительные операции, существуют классы общего назначения, которые вы можете использовать в своем коде. Неважно, создаете ли вы приложения для Интернета, настольных компьютеров, мобильных устройств или облака, вам помогут классы и методы общего назначения.

Как вы можете себе представить, наличие огромной библиотеки функций, доступных вашим приложениям, значительно экономит время для вас как разработчика программного обеспечения. Классы и методы в библиотеке классов .NET созданы Microsoft и доступны для использования в ваших приложениях.

### Даже типы данных являются частью библиотеки классов .NET.
Типы данных C# (такие как string и int) фактически доступны через классы в библиотеке классов .NET. Язык C# маскирует связь между типами данных и классами .NET, чтобы упростить вашу работу. Однако «за кулисами» типы данных реализуются так же, как и любой другой класс в библиотеке классов .NET. Это соединение предоставляет вашим повседневным переменным встроенные методы, которые могут быть очень полезны. Класс string имеет множество таких полезных методов. Например, класс string имеет методы для преобразования текста в верхний и нижний регистр (ToUpper и ToLower).

### Как найти то, что вам нужно, в библиотеке классов .NET

При таком количестве классов и методов как найти то, что нужно для вашего приложения?

Прежде всего, помните, что поиск каждого класса и метода в библиотеке классов .NET подобен поиску каждой книги в большой публичной библиотеке. Вам не нужна каждая книга в библиотеке, и вы не будете использовать все классы и методы в библиотеке классов .NET. В зависимости от типов проектов, над которыми вы работаете, вы будете лучше разбираться в одних частях библиотеки классов .NET и меньше - в других. Опять же, это похоже на то, как вы проводите время в одном из разделов публичной библиотеки: со временем вы знакомитесь с тем, что там есть. Никто не знает всей библиотеки классов .NET, даже те, кто работает в Microsoft.

Во-вторых, необходимость подтолкнет вас к тому, что вам нужно. Большинство людей идут в библиотеку, когда им нужно найти книгу, а не для того, чтобы посмотреть, сколько разных книг они смогут найти. Вам не нужно изучать классы и методы без причины. Когда у вас возникают проблемы с решением какой-либо задачи по программированию, вы можете воспользоваться своей любимой поисковой системой, чтобы найти записи в блогах, статьи или форумы, где другие разработчики решали подобные проблемы. Сторонние источники могут подсказать вам, какие классы и методы .NET вам следует использовать, и вы даже найдете примеры кода, которые сможете опробовать.

В-третьих, Microsoft предоставляет онлайновый справочник по языку и руководство по программированию на C#, в котором вы можете найти нужную информацию. Скорее всего, вы потратите время на чтение документации Microsoft, когда вам нужно будет понять, что именно делают методы, как они работают и каковы их ограничения. Эта документация станет для вас источником истины по библиотеке классов .NET. Команда разработчиков документации Microsoft тесно сотрудничает с разработчиками программного обеспечения .NET Class Library, чтобы обеспечить точность документации.

Наконец, когда вы начнете экспериментировать с небольшими проектами кода, вы углубите свое понимание того, как работают классы и методы.

Все разработчики программного обеспечения следуют схожему процессу, когда ступают на незнакомую территорию. Процесс познания приятен, хотя и сложен.

### Резюме
Библиотека классов .NET предоставляет вам множество функциональных возможностей, которые вы можете использовать, просто ссылаясь на нужные вам классы и методы.
Даже ваши типы данных являются частью библиотеки классов .NET. C# просто предоставляет псевдоним для этих типов данных.

## Упражнение. Вызов методов класса .NET.

Осознаете вы это или нет, но вы вызываете методы C# с момента своего первого «Hello, World!» приложение. Это приложение использует метод WriteLine() класса Console для отображения сообщения «Hello, World!».

Однако не все классы и методы реализуются одинаково. В этом разделе рассматриваются некоторые из наиболее распространенных вариантов, которые вам нужно будет понять при использовании методов из библиотеки классов .NET. Более того, вы узнаете, как найти и использовать документацию, чтобы лучше понять каждый метод.

### Как вызывать методы в библиотеке классов .NET
Из вашего предыдущего опыта работы с методом Console.WriteLine() вы уже должны знать основы:

- Начните с ввода имени класса. В данном случае имя класса - Console.
- Добавьте оператор доступа к члену, символ .
- Добавьте имя метода. В данном случае имя метода - WriteLine.
- Добавьте оператор вызова метода, который представляет собой набор круглых скобок ().
- Наконец, укажите аргументы, которые передаются методу, если таковые имеются, между скобками оператора вызова метода. В данном случае вы указываете текст, который метод Console.WriteLine() должен вывести на консоль (например, «Hello World!»).

Опционально, в зависимости от того, как разработчики спроектировали и реализовали данный метод, вам также может понадобиться:

- Передать дополнительные значения в качестве входных параметров.
- Принимать возвращаемое значение.
- 
В следующем разделе вы рассмотрите, как передавать входные значения в метод и как метод может быть использован для возврата значения в вызывающую процедуру.

Хотя некоторые методы можно вызывать так же, как и Console.WriteLine(), в библиотеке классов .NET есть и другие методы, которые требуют иного подхода.

### Вызов различных методов в библиотеке классов .NET.

1. В редакторе кода Visual Studio, чтобы создать пример кода, реализующий методы классов System.Random и System.Console, введите следующий код:
```cs
Random dice = new Random();
int roll = dice.Next(1, 7);
Console.WriteLine(roll);
```
Этот код имитирует бросок игральной кости, используя метод Random.Next() для генерации числа и метод Console.WriteLine() для отображения значения.

:::note
Вы подробно изучите код позже в этом разделе.
:::

2. Запустите код

Обратите внимание, что в выводе консоли отображается число от 1 до 6 (количество точек на игральной кости). Если вы запустите код достаточное количество раз, вы в конечном итоге увидите каждое из отображаемых чисел.

3. Уделите минуту изучению синтаксиса, используемого для доступа к методам Next() и WriteLine().
```cs
Random dice = new Random();
int roll = dice.Next(1, 7);
Console.WriteLine(roll);
```

В третьей строке кода вы включаете ссылку на класс Console и вызываете метод Console.WriteLine() напрямую. Однако для вызова метода Random.Next() вы используете другую технику. Причина, по которой вы используете две разные техники, заключается в том, что некоторые методы являются «stateful», а другие - «stateless». Разницу между методами с состоянием и без состояния вы рассмотрите в следующем разделе.

### Методы с сохранением состояния и без сохранения состояния («stateful», и «stateless»)

В проектах по разработке программного обеспечения термин «состояние» используется для описания состояния среды выполнения в определенный момент времени. По мере того как ваш код выполняется строка за строкой, значения сохраняются в переменных. В любой момент выполнения текущее состояние приложения - это совокупность всех значений, хранящихся в памяти.

Некоторые методы не зависят от текущего состояния приложения, чтобы работать правильно. Другими словами, методы без состояния реализуются таким образом, чтобы они могли работать без ссылок или изменения каких-либо значений, уже хранящихся в памяти. Методы без статики также известны как статические методы.

Например, метод Console.WriteLine() не опирается на какие-либо значения, хранящиеся в памяти. Он выполняет свою функцию и завершает работу, никак не влияя на состояние приложения.

Другие методы, однако, должны иметь доступ к состоянию приложения, чтобы работать правильно. Другими словами, методы с состоянием строятся таким образом, что они полагаются на значения, сохраненные в памяти предыдущими строками кода, которые уже были выполнены. Или же они изменяют состояние приложения, обновляя значения или сохраняя новые значения в памяти. Их также называют методами экземпляра.

Методы с состоянием (экземпляры) хранят информацию о своем состоянии в полях, которые являются переменными, определенными в классе. Каждый новый экземпляр класса получает свою собственную копию этих полей для хранения состояния.

Один класс может поддерживать как stateful, так и stateless методы. Однако, когда вам нужно вызвать методы с состоянием, вы должны сначала создать экземпляр класса, чтобы метод мог получить доступ к состоянию.

### Создание экземпляра класса

Экземпляр класса называется объектом. Чтобы создать новый экземпляр класса, вы используете новый оператор. Рассмотрим следующую строку кода, которая создает новый экземпляр класса Random для создания нового объекта с именем dice
```cs
Random dice = new Random();
```
Оператор new выполняет несколько важных действий:

- Сначала он запрашивает адрес в памяти компьютера, достаточно большой для хранения нового объекта, основанного на классе Random.
- Он создает новый объект и сохраняет его по адресу в памяти.
- Он возвращает адрес памяти, чтобы его можно было сохранить в объекте dice.

С этого момента, когда в коде появляется ссылка на объект dice, .NET Runtime выполняет поиск за кулисами, чтобы создать иллюзию, что вы работаете непосредственно с самим объектом.

Ваш код использует объект dice как переменную, которая хранит состояние класса Random. Когда вы вызываете метод Next() на объекте dice, метод использует состояние, хранящееся в объекте dice, для генерации случайного числа.

Последняя версия .NET Runtime позволяет инстанцировать объект без необходимости повторять имя типа (вызов конструктора с целевым типом). Например, следующий код создаст новый экземпляр класса Random:
```cs
Random dice = new();
```

Цель состоит в том, чтобы упростить читаемость кода. Вы всегда используете круглые скобки при написании выражения целевого типа new.

### Почему метод Next() сохраняет состояние?

Возможно, вы задаетесь вопросом, почему метод Next() был реализован как метод с состоянием? Неужели разработчики библиотеки классов .NET не могли придумать способ генерировать случайное число, не требуя состояния? И что именно хранится или на что ссылается метод Next()?

Это справедливые вопросы. На высоком уровне компьютеры хороши тем, что выполняют определенные инструкции для получения надежного и повторяющегося результата. Чтобы создать иллюзию случайности, разработчики метода Next() решили фиксировать дату и время вплоть до долей миллисекунды и использовать их для запуска алгоритма, который каждый раз выдает разные числа. Хотя это и не совсем случайное число, но для большинства приложений этого вполне достаточно. Состояние, которое фиксируется и сохраняется в течение всего времени жизни объекта dice, является начальным значением. Каждый последующий вызов метода Next() заново запускает алгоритм, но гарантирует, что начальное значение изменится, так что одно и то же значение не будет (обязательно) возвращено.

Для использования метода Random.Next(), однако, не обязательно понимать, как он работает. Важно знать, что некоторые методы требуют создания экземпляра класса перед вызовом, а другие - нет.

### Как определить, нужно ли создавать экземпляр класса перед вызовом его методов?

Один из подходов к определению того, является ли метод сохраняющим или не сохраняющим состояние, — это обратиться к документации. В документации есть примеры, показывающие, следует ли вызывать метод из экземпляра объекта или непосредственно из класса.

:::note
Возможно, вам придется прокрутить страницу документации вниз, чтобы найти примеры кода.
:::

В качестве альтернативы поиску в документации по продукту вы можете попытаться получить доступ к методу непосредственно из самого класса. Если это работает, вы знаете, что это метод без сохранения состояния. Худшее, что может случиться, — это ошибка компиляции.

1. Введите следующую строку кода в редактор кода Visual Studio:
```cs
int result = Random.Next();
```
Вы уже знаете, что Next() — это метод с отслеживанием состояния, однако этот пример демонстрирует, как редактор кода Visual Studio реагирует на неправильную попытку доступа к методу.

2. Обратите внимание, что под Random.Next появляется красная волнистая линия, указывающая на ошибку компиляции. Если метод, который вас интересует, не имеет состояния, красная волнистая линия не появится.

3. Наведите указатель мыши на красную волнистую линию. Должно появиться всплывающее окно со следующим сообщением:
```
(1,14): error CS0120: An object reference is required for the non-static field, method, or property 'Random.Next()'
```
Как вы видели в коде в начале модуля, вы можете исправить эту ошибку, создав экземпляр класса Random перед доступом к методу Next(). Например:
```cs
Random dice = new Random();
int roll = dice.Next();
```
В этом случае метод Next() вызывается без входных параметров.

### Резюме
- Для вызова методов класса в библиотеке классов .NET используется формат ClassName.MethodName(), где символ . - это оператор доступа к члену класса, а символы () - операторы вызова метода.
- При вызове метода без состояния не нужно сначала создавать новый экземпляр его класса.
- При вызове метода с состоянием необходимо создать экземпляр класса и получить доступ к методу на объекте.
- Для создания нового экземпляра класса используйте оператор new.
- Экземпляр класса называется объектом.

## Упражнение. Возвращаемые значения и параметры методов

В предыдущем разделе вы использовали сценарий кодирования «бросок кубика», чтобы проиллюстрировать разницу между методами с состоянием (экземпляром) и без состояния (статическими). Этот же сценарий может помочь вам понять другие важные понятия о вызове методов. 
Например:
- обработка возвращаемого значения метода.
- параметры метода и передача аргументов в метод.
- выбор перегруженной версии метода.

### Возвращаемые значения

Некоторые методы предназначены для завершения своей функции и «тихого» завершения. Другими словами, они не возвращают значение после завершения работы. Такие методы называются void методами.

Другие методы предназначены для возврата значения по завершении работы. Возвращаемое значение обычно является результатом операции. Возвращаемое значение - это основной способ связи метода с кодом, который его вызывает.

Вы видели, что метод Random.Next() возвращает тип int, содержащий значение случайно сгенерированного числа. Однако метод может быть спроектирован так, чтобы возвращать любой тип данных, даже другого класса. Например, в классе String есть методы, возвращающие строку, есть методы, возвращающие целое число, а есть методы, возвращающие булево значение.

При вызове метода, возвращающего значение, вы часто присваиваете возвращаемое значение переменной. Таким образом, вы сможете использовать это значение позже в своем коде. В сценарии с игральными костями вы присвоили возвращаемое значение Random.Next() переменной roll:
```cs
int roll = dice.Next(1, 7);
```
В некоторых случаях вам может потребоваться использовать возвращаемое значение напрямую, не присваивая его переменной. Например, вы можете вывести возвращаемое значение на консоль следующим образом:
```cs
Console.WriteLine(dice.Next(1, 7));
```
Несмотря на то, что метод возвращает значение, его можно вызвать без использования возвращаемого значения. Например, вы можете игнорировать возвращаемое значение, вызвав метод следующим образом:
```cs
dice.Next(1, 7);
```
Однако игнорировать возвращаемое значение было бы бессмысленно. Причина, по которой вы вызываете метод Next(), заключается в том, что вы можете получить следующее случайное значение.

### Параметры и аргументы метода в вызывающем операторе

Когда вы вызываете метод, вы можете передать ему значения, которые метод будет использовать для выполнения своей задачи. Эти значения называются аргументами. Метод использует аргументы для присвоения значений параметрам, которые определены в сигнатуре метода. Метод может требовать один или несколько параметров для выполнения своей задачи или не требовать их вовсе.

:::note
Часто термины «параметр» и «аргумент» используются как синонимы. Однако «параметр» относится к переменной, которая используется внутри метода. «Аргумент» — это значение, передаваемое при вызове метода.
:::

Большинство методов рассчитаны на прием одного или нескольких параметров. Параметры могут использоваться для настройки того, как метод выполняет свою работу, или же с ними можно работать напрямую. Например, метод Random.Next() использует параметры для настройки верхней и нижней границ возвращаемого значения. Однако метод Console.WriteLine() использует параметр напрямую, выводя значение на консоль.

Методы используют сигнатуру метода для определения количества параметров, которые метод будет принимать, а также типа данных каждого параметра. Оператор кодирования, вызывающий метод, должен соответствовать требованиям, указанным в сигнатуре метода. Некоторые методы предоставляют опции для количества и типа параметров, которые принимает метод.

Когда вызывающая сторона вызывает метод, она предоставляет конкретные значения, называемые аргументами, для каждого параметра. Аргументы должны быть совместимы с типом параметра. Однако имя аргумента, если оно используется в вызывающем коде, не обязательно должно совпадать с именем параметра, определенного в методе.

Рассмотрим следующий код:
```cs
Random dice = new Random();
int roll = dice.Next(1, 7);
Console.WriteLine(roll);
```
Первая строка кода создает экземпляр класса Random с именем dice. Во второй строке кода используется метод dice.Next(1, 7) для присвоения случайного значения целому числу с именем roll. Обратите внимание, что оператор вызова содержит два аргумента, разделенных символом ,. Метод Next() включает сигнатуру метода, которая принимает два параметра типа int. Эти параметры используются для настройки нижней и верхней границ возвращаемого случайного числа. В последней строке кода используется метод Console.WriteLine() для печати значения roll на консоль.

Аргументы, передаваемые методу, должны иметь тот же тип данных, что и соответствующие параметры, определенные методом. Если вы попытаетесь передать методу аргумент с неправильным типом, компилятор C# поймает вашу ошибку и заставит вас обновить оператор вызова, прежде чем ваш код будет скомпилирован и запущен. Проверка типов - это один из способов, с помощью которого C# и .NET предотвращают появление ошибок у конечных пользователей во время выполнения программы.

:::note
Хотя параметры часто используются, не все методы требуют параметров для выполнения своей задачи. Например, в классе Console есть метод Console.Clear(), который не использует параметры. Поскольку этот метод используется для очистки любой информации, отображаемой в консоли, ему не нужны параметры для выполнения своей задачи.
:::

### Перегрузка методов

Многие методы в библиотеке классов .NET имеют перегруженные сигнатуры методов. Это, в частности, позволяет вызывать метод с аргументами, указанными в операторе вызова, или без них.

Перегруженный метод определяется с помощью нескольких сигнатур метода. Перегруженные методы обеспечивают различные способы вызова метода или предоставляют различные типы данных.

В некоторых случаях перегруженные версии метода используются для определения параметра, использующего различные типы данных. Например, метод Console.WriteLine() имеет 19 различных перегруженных версий. Большинство из этих перегрузок позволяют методу принимать данные различных типов, а затем записывать указанную информацию на консоль. Рассмотрим следующий код:
```cs
int number = 7;
string text = "seven";

Console.WriteLine(number);
Console.WriteLine();
Console.WriteLine(text);
```
В этом примере вы вызываете три отдельные перегруженные версии метода WriteLine().

- Первый метод WriteLine() использует сигнатуру метода, определяющую параметр int.
- Второй метод WriteLine() использует сигнатуру метода, определяющую нулевые параметры.
- Третий метод WriteLine() использует сигнатуру метода, определяющую строковый параметр.

В других случаях перегруженные версии метода определяют другое количество параметров. Альтернативные параметры могут быть использованы для обеспечения большего контроля над желаемым результатом. Например, метод Random.Next() имеет перегруженные версии, которые позволяют задавать различные уровни ограничений на случайно сгенерированное число.

В следующем упражнении метод Random.Next() вызывается для генерации случайных целых значений с различными уровнями ограничений:

1. Чтобы изучить перегруженные версии метода Random.Next(), введите следующий код:
```cs
Random dice = new Random();
int roll1 = dice.Next();
int roll2 = dice.Next(101);
int roll3 = dice.Next(50, 101);

Console.WriteLine($"First roll: {roll1}");
Console.WriteLine($"Second roll: {roll2}");
Console.WriteLine($"Third roll: {roll3}");
```

2. Обратите внимание, что ваш результат аналогичен следующему выводу:
```
First roll: 342585470
Second roll: 43
Third roll: 89
```
Генерируемые числа являются случайными, поэтому ваши результаты будут разными. Однако этот пример демонстрирует диапазон результатов, которые вы можете увидеть.

Уделите минуту изучению кода.

- В первой версии метода Next() верхняя и нижняя границы не заданы, поэтому метод вернет значения от 0 до 2 147 483 647, что является максимальным значением, которое может хранить int.
- Во второй версии метода Next() в качестве верхней границы указывается максимальное значение, поэтому в данном случае можно ожидать случайное значение в диапазоне от 0 до 100.
- В третьей версии метода Next() указываются и минимальное, и максимальное значения, поэтому в данном случае можно ожидать случайное значение в диапазоне от 50 до 100.

### Резюме

Вы уже изучили несколько тем в этом разделе. Вот краткий список того, что вы уже изучили:

- Вы изучили, как использовать возвращаемое значение метода (когда метод предоставляет возвращаемое значение).
- Вы изучили, как метод может использовать параметры, которые определены как конкретные типы данных.
- Вы рассмотрели перегруженные версии некоторых методов, которые включают различные параметры или типы параметров.

## Используйте IntelliSense

Visual Studio включает функции IntelliSense, которые работают на основе языковой службы. Например, языковая служба C# обеспечивает интеллектуальное завершение кода на основе семантики языка и анализа вашего исходного кода. В этом разделе вы воспользуетесь IntelliSense, чтобы помочь вам реализовать метод Random.Next().

Поскольку IntelliSense находится внутри редактора кода, вы можете узнать много нового о методе, не покидая среды разработки. IntelliSense предоставляет подсказки и справочную информацию во всплывающем окне под курсором по мере ввода кода. Когда вы набираете код, всплывающее окно IntelliSense будет менять свое содержимое в зависимости от контекста.

Например, если вы медленно вводите слово dice, IntelliSense покажет все ключевые слова C#, идентификаторы (точнее, имена переменных в коде) и классы в библиотеке классов .NET, которые соответствуют введенным буквам. Функции автозаполнения редактора кода можно использовать для завершения ввода слова, которое является верхним совпадением во всплывающем окне IntelliSense. Попробуйте.

1. Ваше приложение должно содержать следующий код:
```cs
Random dice = new Random();
int roll1 = dice.Next();
int roll2 = dice.Next(101);
int roll3 = dice.Next(50, 101);

Console.WriteLine($"First roll: {roll1}");
Console.WriteLine($"Second roll: {roll2}");
Console.WriteLine($"Third roll: {roll3}");
```
2. Чтобы поэкспериментировать с IntelliSense, в нижней части файла кода медленно введите буквы d, i, затем c.

Обратите внимание на всплывающее окно IntelliSense, которое появляется, когда вы начинаете печатать. 

3. Когда появится IntelliSense, должен появиться список предложений. К тому времени, когда вы введете dic, кубик-идентификатор должен находиться в верхней части списка.

4. Нажмите клавишу Tab на клавиатуре. 

Обратите внимание, что все слово dice заполнено в редакторе. Вы можете использовать клавиши со стрелками вверх и вниз, чтобы изменить выбор, прежде чем нажимать клавишу Tab.

:::note
Если окно IntelliSense исчезнет, ​​его можно выбрать с помощью клавиши возврата на клавиатуре, а затем повторно ввести последний символ, чтобы снова открыть IntelliSense.
:::

5. Чтобы указать оператора доступа к членам, введите расширение символ . . Обратите внимание, что всплывающее окно IntelliSense появляется снова, когда вы вводите . и показывает нефильтрованный список всех доступных методов (и других членов класса).
   
6. Введите N Список будет отфильтрован, и слово «Next» должно быть первым.
7. Чтобы автозаполнить все слово, нажмите клавишу Tab.
8. Чтобы указать оператор вызова метода, введите (

Обратите внимание, что закрывающая скобка добавляется автоматически.

Оператор вызова метода - это набор круглых скобок, расположенных справа от имени метода. В этой части оператора вызова указываются аргументы, которые будут переданы методу. Оператор вызова метода необходим при вызове метода.

9. Обратите внимание, что всплывающее окно IntelliSense теперь отображает подробную информацию о методе Random.Next().
10. Уделите минуту изучению всплывающего окна IntelliSense для метода Random.Next().

:::note
Если всплывающее окно IntelliSense закрылось до того, как вы успели его изучить, удалите оператор вызова (), а затем введите (, чтобы отобразить всплывающее окно IntelliSense.
:::
Обратите внимание, что во всплывающем окне есть три секции, одна слева и две справа.

В правой части вы должны увидеть int Random.Next(int minValue, int maxValue) в верхней секции и Returns a non-negative random integer. в нижней секции. int определяет возвращаемый тип метода. Другими словами, при выполнении этой версии метода он вернет значение типа int.

В левой части всплывающего окна IntelliSense отображается 1/3.

1/3 указывает на то, что перед вами первая из трех сигнатур методов для метода Next(). Обратите внимание, что эта версия сигнатуры метода позволяет методу работать без параметров (никаких аргументов, передаваемых методу в операторе вызова).

Обратите внимание, что над и под цифрой 1/3 также есть маленькая стрелка.
11. Чтобы рассмотреть вторую перегруженную версию метода, нажмите на клавиатуре клавишу со стрелкой вниз.

Обратите внимание, что вы можете использовать клавиши со стрелками вверх и вниз, чтобы перемещаться между различными перегруженными версиями. При этом в левой части всплывающего окна IntelliSense появятся значения 1/3, 2/3 и 3/3, а в правой - полезные пояснения.

11. Потратьте минуту на изучение каждой из перегруженных версий метода Random.Next().

Вторая перегруженная версия метода, 2/3, сообщает вам, что метод Next() может принимать параметр int maxValue. В описании говорится, что maxValue - это исключительная верхняя граница числа, которое вы хотите сгенерировать методом Next(). Исключительная указывает на то, что возвращаемое число будет меньше maxValue. Поэтому, когда вы укажете dice.Next(1,7); максимальный бросок костей будет равен 6. Обратите внимание, что сообщение в нижней части раздела было обновлено до: Возвращает неотрицательное случайное целое число, которое меньше заданного максимума.

Третья версия метода, 3/3, сообщает, что метод Next() может принимать в качестве параметров как int minValue, так и int maxValue. Новый параметр, minValue, представляет собой нижнюю границу числа, которое вы хотите сгенерировать методом Next(). Поскольку нижняя граница является инклюзивной, а не эксклюзивной, возвращаемое значение может быть равно minValue. Сообщение внизу теперь гласит: Возвращает случайное целое число, находящееся в указанном диапазоне.

В этом случае IntelliSense предоставляет всю информацию, необходимую для выбора подходящей перегрузки, включая подробное объяснение maxValue и minValue. Однако вы можете столкнуться с ситуацией, когда вам потребуется обратиться к документации по методу.

### Используйте сайт learn.microsoft.com для получения информации о перегруженных методах.

Второй способ узнать о перегруженных версиях методов — обратиться к документации по методу. Документация также поможет вам понять, для чего именно предназначен каждый параметр.

1. Для начала откройте предпочтительный веб-браузер и поисковую систему.

2. Выполните поиск по запросу C# Random.Next().

Поиск должен включать имя класса и имя метода. Вы также можете включить термин C#, чтобы случайно не получить результаты по другим языкам программирования.

3. Выберите верхний результат поиска, URL которого начинается с https://learn.microsoft.com.

Один из верхних результатов поиска должен вести на URL-адрес, начинающийся с https://learn.microsoft.com. В этом случае заголовок ссылки должен выглядеть как Random.Next Method.

Вот ссылка на случай, если у вас возникнут проблемы с ее поиском с помощью поисковой системы: [https://learn.microsoft.com/ru-ru/dotnet/api/system.random.next?view=net-8.0](https://learn.microsoft.com/ru-ru/dotnet/api/system.random.next?view=net-8.0)

4. Откройте ссылку для C# Random.Next().

5. Быстро просмотрите документацию.

Прокрутите содержимое страницы вниз, чтобы увидеть различные примеры кода. Обратите внимание, что примеры можно запускать в окне браузера.

Документация learn.microsoft.com имеет стандартный формат для каждого класса и метода в библиотеке классов .NET.

6. В верхней части веб-страницы найдите раздел с надписью Overloads.

Обратите внимание, что в нем перечислены три перегруженные версии метода. Каждая из перечисленных перегруженных версий содержит гиперссылку на место, расположенное дальше на странице.

7. Чтобы перейти «на страницу» к описанию второй перегруженной версии, выберите Next(Int32).

Документация для каждой версии метода включает:

- Краткое описание функциональности метода
- Определение метода
- Параметры, которые принимает метод
- Возвращаемые значения
- Исключения, которые могут быть вызваны
- Примеры использования метода
- Другие замечания о методе
8. Уделите минуту просмотру раздела Parameters.

В разделе «Параметры» вы можете прочитать, что параметр maxValue - это «исключительная верхняя граница генерируемого случайного числа». Исключительная верхняя граница означает, что если вы хотите получить число не больше 10, вы должны передать значение 11.

Вы также можете прочитать в следующей строке: «maxValue должно быть больше или равно 0». Что произойдет, если проигнорировать это утверждение? В разделе исключений видно, что метод вернет исключение ArgumentOutOfRangeException, если maxValue меньше 0.

:::warning
Содержимое сайта Learn.microsoft.com является «источником истины» для библиотеки классов .NET. Важно потратить время на чтение документации, чтобы понять, как будет работать тот или иной метод.
:::

### Обзор
- Методы могут не принимать никаких параметров или принимать несколько параметров, в зависимости от того, как они были разработаны и реализованы. При передаче нескольких параметров разделяйте их символом ,.
- Методы могут возвращать значение, когда выполняют свою задачу, или ничего не возвращать (void).
- Перегруженные методы поддерживают несколько реализаций метода, каждая из которых имеет уникальную сигнатуру метода (количество параметров и тип данных каждого параметра).
- IntelliSense помогает быстрее писать код. Она предоставляет быструю ссылку на методы, их возвращаемые значения, перегруженные версии и типы параметров.
- learn.microsoft.com - это «источник истины», когда вы хотите узнать, как работают методы в библиотеке классов .NET.

## Упражнение — выполните задание, чтобы обнаружить и реализовать вызов метода.

Задания по коду закрепят полученные знания и помогут вам обрести уверенность, прежде чем продолжить

### Задача методов математического класса 
В этом задании вы будете использовать Intellisense или Learn.microsoft.com, чтобы найти и вызвать метод, который возвращает большее из двух чисел.

### Реализовать метод класса Math, который возвращает большее из двух чисел.
1. Введите следующий код в качестве отправной точки для вашего задания.
```cs
int firstValue = 500;
int secondValue = 600;
int largerValue;

Console.WriteLine(largerValue);
```
:::note
Ваше окончательное решение этой задачи должно использовать этот код и использовать Console.WriteLine(largerValue); оператор для генерации вывода.
:::

2. Найдите метод класса System.Math, который возвращает большее из двух чисел. 

Вы можете использовать код Visual Studio «Intellisense» или Learn.microsoft.com, чтобы найти метод и определить, как его правильно вызывать.

3. Используйте найденный метод для присвоения значения переменной с именем largerValue.

Вы должны иметь возможность передать два целочисленных значения, firstValue и secondValue, в найденный метод. Метод должен вернуть значение типа int, представляющее больший из двух переданных аргументов.

Вы можете присвоить возвращаемое значение largerValue в новой строке кода или в существующей строке кода, которая используется для объявления largerValue.

4. Убедитесь, что ваше приложение записывает следующий вывод
```
600
```

## Заключение
Вашей целью было вызвать методы, определенные в библиотеке классов .NET, для выполнения таких задач, как генерация случайного числа или выполнение математической операции.

Используя синтаксис C#, вы вызывали различные типы методов в библиотеке классов .NET: методы, возвращающие значения, методы, принимающие несколько входных параметров, и методы, сохраняющие состояние. Вы использовали Visual Studio IntelliSense и learn.microsoft.com для изучения методов и улучшения понимания того, что делает метод и как он работает.

Представьте, сколько усилий потребовалось бы для разработки программного обеспечения, если бы у вас не было огромной библиотеки классов и методов (все из которых вам не нужно было бы создавать лично). Библиотека классов .NET - это благо для миллионов разработчиков. Десятки тысяч компаний используют приложения, созданные на основе методов, реализованных в библиотеке классов .NET.

Научившись использовать библиотеку классов .NET, вы сделали большой шаг к пониманию того, как разработчики программного обеспечения создают реальные приложения.










