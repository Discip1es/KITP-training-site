# Напишите ваш первый метод

## Введение

Язык программирования C# позволяет создавать всевозможные надежные приложения. Предположим, вам нужно написать код для выполнения операций с непредсказуемым пользовательским вводом. Возможно, вам потребуется добавить логику для обработки неправильного ввода, преобразования ввода в удобный формат и выполнения правильной операции. По мере того как ваши приложения увеличиваются в размерах, отслеживание кода может быстро превратиться в проблему.

Методы, также называемые функциями, являются ключевой частью структурированного, эффективного и читабельного кода. Метод - это модульная единица кода и фундаментальная концепция программирования. Метод часто предназначен для выполнения определенной задачи и содержит код для ее выполнения. Название метода должно четко отражать его задачу, что улучшает читаемость кода. Изучение методов поможет вам быстрее создавать многофункциональные приложения.

В этом модуле вы научитесь создавать собственные методы для выполнения конкретных задач. Вы узнаете, как методы могут упростить и сократить код, а также упорядочить его и облегчить поиск.

**Цели обучения**
В этом модуле вы узнаете как:
- Создадите свой первый метод на языке c sharp
- Определять части кода, которые могут быть модульными
- Использовать методы для организации кода в конкретные задачи

## Понимание синтаксиса методов

Возможно, вы уже знакомы с некоторыми методами, такими как Console.WriteLine() или random.Next(). Возможно, вы оценили, как эти методы упрощают задачи и позволяют вам легче строить код. В этом разделе вы узнаете, как создавать собственные методы.

### Как работают методы

Процесс разработки метода начинается с создания сигнатуры метода. В сигнатуре метода объявляется тип возврата, имя и входные параметры метода. Например, рассмотрим следующую сигнатуру метода:

```cs
void SayHello();
```
Имя метода - SayHello. Его тип возврата - void, то есть метод не возвращает никаких данных. Однако методы могут возвращать значение любого типа данных, например bool, int, double, а также массивы. Параметры метода, если таковые имеются, должны быть заключены в круглую скобку (). Методы могут принимать несколько параметров любого типа данных. В данном примере метод не имеет параметров. 

Прежде чем запустить метод, необходимо добавить его определение. В определении метода с помощью скобок {} указывается код, который будет выполняться при вызове метода. Например:

```cs
void SayHello() 
{
    Console.WriteLine("Hello World!");
}
```
Теперь метод будет печатать "Hello World!" при каждом вызове.

###  Вызов метода

Метод вызывается с помощью его имени и необходимых аргументов. Рассмотрим следующее:
```cs
Console.Write("Input!");
```
Строка "Input!" является аргументом, предоставляемым методу Write. 

Метод может быть вызван до или после его определения. Например, метод SayHello можно определить и вызвать, используя следующий синтаксис:
```cs
SayHello();

void SayHello() 
{
    Console.WriteLine("Hello World!");
}
```
Обратите внимание, что не обязательно определять метод до его вызова. Такая гибкость позволяет организовать код по своему усмотрению. Обычно все методы определяются в конце программы. Например:
```cs
int[] a = {1,2,3,4,5};

Console.WriteLine("Contents of Array:");
PrintArray();

void PrintArray()
{
    foreach (int x in a)
    {
        Console.Write($"{x} ");
    }
    Console.WriteLine();
}
```
### Выполнение метода

Когда вы вызываете метод, код в теле метода будет выполнен. Это означает, что управление выполнением передается от вызывающего метода к методу. Управление возвращается вызывающему методу после того, как метод завершает свое выполнение. Например, рассмотрим следующий код:
```cs
Console.WriteLine("Before calling a method");
SayHello();
Console.WriteLine("After calling a method");

void SayHello() 
{
    Console.WriteLine("Hello World!");
}
```
Этот код выводит следующий результат:
```
Before calling a method
Hello World!
After calling a method
```
Как только метод определен, его можно вызывать в любое время и столько раз, сколько вам нужно. Вы можете использовать методы внутри операторов if-else, циклов for, операторов switch, даже для инициализации переменных и многого другого!

### Лучшие практики
При выборе имени метода важно, чтобы оно было кратким и давало понять, какую задачу выполняет метод. Имена методов должны быть в регистре Паскаля и, как правило, не должны начинаться с цифр. Имена параметров должны описывать, какую информацию представляет параметр. Рассмотрим следующие сигнатуры методов:
```cs
void ShowData(string a, int b, int c);
void DisplayDate(string month, int day, int year);
```
Второй метод описывает, какие данные выводятся на экран, и дает описательные имена для параметров. Теперь, когда вы освоили основы, вы готовы начать писать свои собственные методы!

## Создайте свой первый метод
Как правило, метод создается для выполнения определенной задачи. В этом упражнении вы создадите метод, который генерирует и выводит на экран пять случайных чисел. Давайте начнем!

### Создайте метод для отображения случайных чисел

Чтобы создать метод, сначала создайте сигнатуру метода, а затем добавьте тело метода. При создании сигнатуры метода вы объявляете возвращаемый тип, имя метода и параметры. Создайте тело метода, используя скобки {}, которые содержат код.

1. Введите следующий код в редактор Visual Studio:
```cs
void DisplayRandomNumbers();
```
В данном случае метод должен только сгенерировать и вывести информацию, поэтому тип возврата - void. Пока что вам не нужно включать никакие параметры.
2. Чтобы создать тело метода, удалите точку с запятой ; и обновите свой код до следующего вида:
```cs
void DisplayRandomNumbers() 
{
    Random random = new Random();
}
```
3. Чтобы вывести на экран пять случайных целых чисел, добавьте в метод цикл for:
```cs
void DisplayRandomNumbers() 
{
    Random random = new Random();

    for (int i = 0; i < 5; i++) 
    {
        Console.Write($"{random.Next(1, 100)} ");
    }
}
```
В этом коде вы генерируете число от 1 до 99 (включительно). Вы также добавляете пробел после вывода числа. Далее вы выводите новую строку перед завершением метода.
4. Обновите свой метод, добавив следующий код:
```cs
void DisplayRandomNumbers() 
{
    Random random = new Random();

    for (int i = 0; i < 5; i++) 
    {
        Console.Write($"{random.Next(1, 100)} ");
    }

    Console.WriteLine();
}
```
Теперь ваш метод будет добавлять новую строку после отображения чисел.

### Вызовите свой метод

1. Введите новую пустую строку кода над методом DisplayRandomNumbers.
2. Введите следующий код в новую пустую строку кода:
```cs
Console.WriteLine("Generating random numbers:");
DisplayRandomNumbers();
```
3. Сравните свой код с приведенным ниже, чтобы убедиться в его правильности:
```cs
Console.WriteLine("Generating random numbers:");
DisplayRandomNumbers();

void DisplayRandomNumbers() 
{
    Random random = new Random();

    for (int i = 0; i < 5; i++) 
    {
        Console.Write($"{random.Next(1, 100)} ");
    }

    Console.WriteLine();
}
```
Обратите внимание, как использование метода упрощает понимание кода. Вместо того чтобы тратить время на самостоятельную расшифровку цикла for, вы можете быстро прочитать имя метода и узнать, что этот код выводит случайные числа.

4. Несколько раз запустите код проверив что он работает верно.

### Резюме

Вот что вы уже узнали о методах: 
- Создавайте метод, объявив возвращаемый тип, имя, входные параметры и тело метода. 
- Имена методов должны четко отражать задачу, которую выполняет метод. 
- Используйте метод, называя его имя и заключая его в круглые скобки ()

## Создание многократно используемых методов
Разрабатывая приложения, вы можете столкнуться с необходимостью писать код для выполнения одних и тех же действий снова и снова. Вместо того чтобы писать дублирующий код, использование метода для выполнения одной и той же задачи сокращает код и помогает быстрее разрабатывать приложения. В этом упражнении вы выявите повторяющийся код и замените его многократно используемым методом. Давайте приступим!

### Выявление дублирующегося кода

В этом задании вы рассмотрите приложение, которое отслеживает время приема лекарств в разных часовых поясах. Пользователь вводит данные о текущем часовом поясе и часовом поясе назначения. На экране отображается расписание приема лекарств, которое затем корректируется с учетом нового часового пояса.

1. Скопируйте и вставьте следующий код в редактор кода Visual Studio
```cs
using System;

int[] times = {800, 1200, 1600, 2000};
int diff = 0;

Console.WriteLine("Enter current GMT");
int currentGMT = Convert.ToInt32(Console.ReadLine());

Console.WriteLine("Current Medicine Schedule:");

/* Format and display medicine times */
foreach (int val in times)
{
    string time = val.ToString();
    int len = time.Length;

    if (len >= 3)
    {
        time = time.Insert(len - 2, ":");
    }
    else if (len == 2)
    {
        time = time.Insert(0, "0:");
    }
    else
    {
        time = time.Insert(0, "0:0");
    }

    Console.Write($"{time} ");
}

Console.WriteLine();

Console.WriteLine("Enter new GMT");
int newGMT = Convert.ToInt32(Console.ReadLine());

if (Math.Abs(newGMT) > 12 || Math.Abs(currentGMT) > 12)
{
    Console.WriteLine("Invalid GMT");
}
else if (newGMT <= 0 && currentGMT <= 0 || newGMT >= 0 && currentGMT >= 0) 
{
    diff = 100 * (Math.Abs(newGMT) - Math.Abs(currentGMT));

    /* Adjust the times by adding the difference, keeping the value within 24 hours */
    for (int i = 0; i < times.Length; i++) 
    {
        times[i] = ((times[i] + diff)) % 2400;
    }
} 
else 
{
    diff = 100 * (Math.Abs(newGMT) + Math.Abs(currentGMT));

    /* Adjust the times by adding the difference, keeping the value within 24 hours */
    for (int i = 0; i < times.Length; i++) 
    {
        times[i] = ((times[i] + diff)) % 2400;
    }
}

Console.WriteLine("New Medicine Schedule:");

/* Format and display medicine times */
foreach (int val in times)
{
    string time = val.ToString();
    int len = time.Length;

    if (len >= 3)
    {
        time = time.Insert(len - 2, ":");
    }
    else if (len == 2)
    {
        time = time.Insert(0, "0:");
    }
    else
    {
        time = time.Insert(0, "0:0");
    }

    Console.Write($"{time} ");
}

Console.WriteLine();
```
2. Обратите внимание, что здесь есть несколько циклов for, которые повторяются с идентичным кодом. 

Есть два цикла foreach, которые форматируют и отображают время лекарств. Еще два цикла for корректируют время в зависимости от разницы часовых поясов. 

В процессе написания кода вы можете обнаружить, что повторяете блоки кода для выполнения одной и той же задачи. Это прекрасная возможность консолидировать код, используя вместо него метод для выполнения задачи. Давайте потренируемся!

### Создайте методы для выполнения повторяющихся задач

Теперь, когда вы определили повторяющийся код, вы можете создать метод, который будет содержать код и удалять дубликаты. Использование методов дает дополнительный бонус - сокращение кода и улучшение читабельности! Циклы foreach форматируют и отображают значения времени, поэтому вы можете дать методу имя, которое четко отражает эту задачу. То же самое можно сделать и с циклом for, который корректирует время. Давайте начнем!

1. Введите новую пустую строку кода в конце предыдущего кода.
2. В новой пустой строке кода создайте сигнатуру метода, введя следующий код:
```cs
void DisplayTimes() 
{

}
```
3. Чтобы определить тело метода, обновите метод DisplayTimes, скопировав и вставив блок foreach следующим образом:
```cs
void DisplayTimes() 
{
    /* Format and display medicine times */
    foreach (int val in times)
    {
        string time = val.ToString();
        int len = time.Length;

        if (len >= 3)
        {
            time = time.Insert(len - 2, ":");
        }
        else if (len == 2)
        {
            time = time.Insert(0, "0:");
        }
        else
        {
            time = time.Insert(0, "0:0");
        }

        Console.Write($"{time} ");
    }

    Console.WriteLine();
}
```
В этом методе вы включаете вызов Console.WriteLine в конце, чтобы добавить новую строку после отображения времени. Далее вы создадите еще один метод для корректировки времени в соответствии с разницей в часовых поясах.
4. Введите новую пустую строку кода в конце предыдущего кода.
5. В новой пустой строке кода создайте сигнатуру метода, введя следующий код:
```cs
void AdjustTimes() 
{

}
```
6. Обновите метод AdjustTimes, скопировав и вставив цикл for следующим образом:
```cs
void AdjustTimes() 
{
    /* Adjust the times by adding the difference, keeping the value within 24 hours */
    for (int i = 0; i < times.Length; i++) 
    {
        times[i] = ((times[i] + diff)) % 2400;
    }
}
```
### Вызовите методы
В этом задании вы удалите повторяющиеся блоки кода и замените их вызовами созданных вами методов.

1. Найдите первый экземпляр повторяющегося цикла foreach под комментарием "Format and display medicine times":
```cs
Console.WriteLine("Current Medicine Schedule:");

/* Format and display medicine times */
foreach (int val in times)
{
    ...
}

Console.WriteLine();

Console.WriteLine("Enter new GMT");
```
2. Замените код, который вы выделили, вызовом метода `DisplayTimes`. В результате замены должен получиться следующий код:
```cs
Console.WriteLine("Current Medicine Schedule:");
DisplayTimes();

Console.WriteLine("Enter new GMT");
```
Далее вы замените второй экземпляр повторяющегося кода.
3. Найдите второй экземпляр цикла foreach под комментарием "Format and display medicine times":
```cs
Console.WriteLine("New Medicine Schedule:");

/* Format and display medicine times */
foreach (int val in times)
{
    ...
}

Console.WriteLine();
```
4. Замените код, который вы выделили, вызовом метода `DisplayTimes`. В результате замены должен получиться следующий код:
```cs
Console.WriteLine("New Medicine Schedule:");
DisplayTimes();
```
Обратите внимание, как использование метода вместо большого блока кода обеспечивает большую ясность и делает код более понятным. Давайте сделаем то же самое с созданным вами методом `AdjustTimes`.
4. Найдите следующий код с дублирующимися циклами for
```cs
else if (newGMT <= 0 && currentGMT <= 0 || newGMT >= 0 && currentGMT >= 0) 
{
    diff = 100 * (Math.Abs(newGMT) - Math.Abs(currentGMT));

    /* Adjust the times by adding the difference, keeping the value within 24 hours */
    for (int i = 0; i < times.Length; i++) 
    {
        times[i] = ((times[i] + diff)) % 2400;
    }
} 
else 
{
    diff = 100 * (Math.Abs(newGMT) + Math.Abs(currentGMT));

    /* Adjust the times by adding the difference, keeping the value within 24 hours */
    for (int i = 0; i < times.Length; i++) 
    {
        times[i] = ((times[i] + diff)) % 2400;
    }
}
```
6. Замените повторяющиеся фрагменты кода под комментарием "Adjust the times by adding the difference" на вызовы вашего метода `AdjustTimes`. В результате замены должен получиться следующий код:
```cs
else if (newGMT <= 0 && currentGMT <= 0 || newGMT >= 0 && currentGMT >= 0) 
{
    diff = 100 * (Math.Abs(newGMT) - Math.Abs(currentGMT));
    AdjustTimes();
} 
else 
{
    diff = 100 * (Math.Abs(newGMT) + Math.Abs(currentGMT));
    AdjustTimes();
}
```
Теперь весь дублирующийся код заменен вашим новым методом. Обратите внимание, насколько более читабельным и лаконичным выглядит ваш код!

### Проверьте свою работу

В этом задании вы запустите свое приложение и убедитесь, что ваш код работает правильно. Давайте начнем.
1. Сравните свой код с приведенным ниже, чтобы убедиться в его правильности:
```cs
int[] times = {800, 1200, 1600, 2000};
int diff = 0;

Console.WriteLine("Enter current GMT");
int currentGMT = Convert.ToInt32(Console.ReadLine());

Console.WriteLine("Current Medicine Schedule:");
DisplayTimes();

Console.WriteLine("Enter new GMT");
int newGMT = Convert.ToInt32(Console.ReadLine());

if (Math.Abs(newGMT) > 12 || Math.Abs(currentGMT) > 12)
{
    Console.WriteLine("Invalid GMT");
}
else if (newGMT <= 0 && currentGMT <= 0 || newGMT >= 0 && currentGMT >= 0) 
{
    diff = 100 * (Math.Abs(newGMT) - Math.Abs(currentGMT));
    AdjustTimes();
} 
else 
{
    diff = 100 * (Math.Abs(newGMT) + Math.Abs(currentGMT));
    AdjustTimes();
}

Console.WriteLine("New Medicine Schedule:");
DisplayTimes();

void DisplayTimes()
{
    /* Format and display medicine times */
    foreach (int val in times)
    {
        string time = val.ToString();
        int len = time.Length;

        if (len >= 3)
        {
            time = time.Insert(len - 2, ":");
        }
        else if (len == 2)
        {
            time = time.Insert(0, "0:");
        }
        else
        {
            time = time.Insert(0, "0:0");
        }

        Console.Write($"{time} ");
    }
    Console.WriteLine();
}

void AdjustTimes() 
{
    /* Adjust the times by adding the difference, keeping the value within 24 hours */
    for (int i = 0; i < times.Length; i++) 
    {
        times[i] = ((times[i] + diff)) % 2400;
    }
}
```
2. Запустите приложение. Введите -6 и +6 для подсказок GMT
3. Убедитесь, что ваш код выдает следующий результат
```
Enter current GMT
-6
Current Medicine Schedule:
8:00 12:00 16:00 20:00 
Enter new GMT
+6
New Medicine Schedule:
20:00 0:00 4:00 8:00
```
Если ваш код показывает другие результаты, вам нужно пересмотреть код, чтобы найти ошибку и внести обновления. Запустите код снова, чтобы проверить, устранили ли вы проблему. Продолжайте обновлять и запускать код до тех пор, пока он не даст ожидаемые результаты.

## Построение кода с помощью методов

Методы полезны для организации кода, повторного использования кода и эффективного решения проблем. Метод можно представить себе как "черный ящик", который принимает входные данные, выполняет названную задачу и возвращает выходные данные. Используя это предположение, вы можете быстро структурировать программы, называя задачи методами, а затем заполняя их логикой после определения всех необходимых задач. 

Когда вы используете простой язык для описания шагов в коде, не придерживаясь строгих правил синтаксиса, вы используете "псевдокод". Сочетание методов и псевдокода - отличный способ быстро справиться с любой сложной задачей программирования.

### Используйте методы для структурирования кода

Предположим, вы - кандидат на собеседование по кодированию. Интервьюер хочет, чтобы вы написали программу, которая проверяет, является ли адрес IPv4 действительным или недействительным. Вам даны следующие правила:  

- Действительный IPv4-адрес состоит из четырех чисел, разделенных точками.
- Каждое число не должно содержать ведущих нулей
- Каждое число должно находиться в диапазоне от 0 до 255

1.1.1.1 и 255.255.255.255 являются примерами действительных IP-адресов.  

IPv4-адрес предоставляется в виде строки. Можно предположить, что он состоит только из цифр и точек (в строке нет букв).  

Как бы вы подошли к решению этой задачи?

### Разберитесь с проблемой

В этом задании вы определите шаги, необходимые для решения проблемы. Если вы внимательно посмотрите на правила, то поймете, что для определения того, является ли IPv4-адрес действительным, требуется всего три шага.  

1. В редакторе кода Visual Studio удалите весь существующий код из предыдущих упражнений.
2. Введите в редактор следующий псевдокод:
```cs
/*
if ipAddress consists of 4 numbers
and
if each ipAddress number has no leading zeroes
and
if each ipAddress number is in range 0 - 255

then ipAddress is valid

else ipAddress is invalid
*/
```
Псевдокод - отличный способ начать решать любую проблему. Используя этот блок комментариев, вы преодолеваете разрыв между правилами подсказки и программным кодом, проясняя основные задачи, которые будет выполнять ваш код. Псевдокод не обязательно должен быть функциональным или придерживаться правил синтаксиса, однако он должен четко объяснять, что будет делать код. Теперь давайте превратим это в настоящий код!

3. Введите новую пустую строку кода, а затем введите следующий код в редакторе:
```cs
if (ValidateLength() && ValidateZeroes() && ValidateRange()) 
{
    Console.WriteLine($"ip is a valid IPv4 address");
} 
else 
{
    Console.WriteLine($"ip is an invalid IPv4 address");
}
```
На этом шаге вы преобразуете операторы if из вашего псевдокода в вызываемые методы и выводите результаты. Пока не стоит беспокоиться об определении методов; можно предположить, что каждый метод выполняет ту задачу, которую описывает его название. Вскоре вы исправите ошибки компиляции и создадите логику методов, а пока сосредоточьтесь на общей картине. Когда вы начинаете работать над новой программой, концентрация на общем дизайне поможет вам оставаться организованным и быстрее разрабатывать приложение.
4. Введите новую пустую строку кода под существующим кодом, а затем введите следующий код в редакторе:
```cs
void ValidateLength() {}
void ValidateZeroes() {}
void ValidateRange() {}
```
Обратите внимание, как использование методов-заместителей позволило вам быстро подойти к решению проблемы и структурировать код для разработки решения. Теперь, когда у вас есть структурированный план, вы можете продолжить решение проблемы, заполняя код по частям.

### Разработайте свое решение

Теперь, когда у вас есть все методы-заместители, необходимые для решения задачи, вы можете сосредоточиться на деталях вашего решения. Помните, что формат ввода IPv4-адреса будет представлять собой строку, состоящую из цифр, разделенных точками. Давайте начинать!

1. В начале программы создайте переменные для хранения статусов ввода и проверки:
```cs
string ipv4Input = "107.31.1.5";
bool validLength = false;
bool validZeroes = false;
bool validRange = false;
```
2. Обновите код решения, чтобы использовать переменные проверки следующим образом:
```cs
ValidateLength(); 
ValidateZeroes(); 
ValidateRange();

if (validLength && validZeroes && validRange) 
{
    Console.WriteLine($"ip is a valid IPv4 address");
} 
else
{
    Console.WriteLine($"ip is an invalid IPv4 address");
}
```
3. Обновите метод `ValidateLength` следующим образом:
```cs
void ValidateLength() 
{
    string[] address = ipv4Input.Split(".");
    validLength = address.Length == 4;
};
```
Первое правило гласит, что адрес IPv4 должен состоять из четырех блоков цифр. Поэтому в этом коде вы используете string.Split для разделения цифр и проверки того, что их четыре.
4. Обновите метод `ValidateZeroes` следующим образом:
```cs
void ValidateZeroes() 
{
    string[] address = ipv4Input.Split(".");

    foreach (string number in address) 
    {
        if (number.Length > 1 && number.StartsWith("0")) 
        {
            validZeroes = false;
        }
    }

    validZeroes = true;
}
```
Подумайте, как это правило переводится в код.  

Второе правило гласит, что числа в IPv4-адресе не должны содержать ведущих нулей. Поэтому метод должен проверять числа на наличие ведущих нулей, принимая `0` в качестве допустимого числа. Если все числа содержат допустимые нули, `validZeroes` должен быть равен `true`, а `false` - в противном случае. Таким образом, в этом коде вы проверяете, что каждое число с более чем одной цифрой не начинается с нуля.  

Если вы внимательно посмотрите, то заметите, что значение `validZeroes` устанавливается в `true` после завершения цикла `foreach`. Однако вы хотите установить `validZeroes` в `true` только в том случае, если не найдено ведущих нулей. Эту ошибку можно исправить, установив `validZeroes = true` перед выполнением цикла `foreach`. Однако эту ошибку можно исправить и с помощью оператора **return**.

5. Обновите свой код следующим образом
```cs
foreach (string number in address) 
{
    if (number.Length > 1 && number.StartsWith("0")) 
    {
        validZeroes = false;
        return;
    }
}
```
Оператор **return** завершает выполнение метода и возвращает управление вызывающему методу. Добавление оператора `return` после `validZeroes = false` приводит к завершению метода после обнаружения первого недопустимого нуля. Если недействительный ноль не найден, метод завершится после установки `validZeroes` в `true`. Перейдем к следующему методу.
6. Обновите метод `ValidateRange` следующим образом:
```cs
void ValidateRange() 
{
    string[] address = ipv4Input.Split(".");

    foreach (string number in address) 
    {
        int value = int.Parse(number);
        if (value < 0 || value > 255) 
        {
            validRange = false;
            return;
        }
    }
    validRange = true;
}
```
Третье правило гласит, что каждое число в IPv4-адресе должно находиться в диапазоне от 0 до 255. Поэтому в этом коде вы проверяете, что каждое число меньше 255, и, если это не так, завершаете выполнение после установки `validRange` в `false`. Поскольку входная строка содержит только цифры и точки, вам не нужно проверять отрицательные числа.  

Однако может возникнуть ситуация, когда между точками нет цифр. Например, «255...255». В этом случае `string.Split(«.»)` вернет пустые записи, что приведет к ошибке `int.Parse`. Вы можете предотвратить это, указав `StringSplitOptions`.
7. Обновите код следующим образом:
```cs
string[] address = ipv4Input.Split(".", StringSplitOptions.RemoveEmptyEntries);
```
Использование `StringSplitOptions.RemoveEmptyEntries` исключает пустые записи из массива `адресов` и предотвращает попытки разбора пустых строк.

### Завершите свое решение

Теперь, когда у вас есть все методы проверки IP-адреса, пришло время пересмотреть ваше первоначальное решение. В этом задании вы добавите больше входных значений и подготовитесь к тестированию своего кода.

1. Найдите следующий код, который вы написали ранее в программе:
```cs
string ipv4Input = "107.31.1.5";
```
2. Обновите код следующим образом:
```cs
string[] ipv4Input = {"107.31.1.5", "255.0.0.255", "555..0.555", "255...255"};
```
При разработке решения важно тестировать код с различными входными данными. В этом коде вы предоставили приличный диапазон тестовых значений. Теперь, когда вы обновили тестовые данные, вам нужно обновить код, чтобы использовать новые значения. Поскольку значения находятся в массиве, вам нужно будет обновить код, чтобы проверить каждое из них с помощью цикла.

3. Обновите код следующим образом:
```cs
foreach (string ip in ipv4Input) 
{
    ValidateLength(); 
    ValidateZeroes(); 
    ValidateRange();

    if (validLength && validZeroes && validRange) 
    {
        Console.WriteLine($"{ip} is a valid IPv4 address");
    } 
    else 
    {
        Console.WriteLine($"{ip} is an invalid IPv4 address");
    }
}
```
Наконец, вам нужно исправить входные данные, используемые каждым методом, поскольку вы обновили `ipv4Input` со строки на массив. Поскольку каждый метод использует `string.Split`, вы можете объявить переменную для хранения результата `string.Split` и использовать ее в каждом методе вместо этого.
4. Добавьте переменную для хранения текущего IPv4-адреса, на который будет ссылаться каждый метод:
```cs
string[] ipv4Input = {"107.31.1.5", "255.0.0.255", "555..0.555", "255...255"};
string[] address;
bool validLength = false;
bool validZeroes = false;
bool validRange = false;
```
5. Инициализируйте `adress` с помощью `string.Split:`
```cs
foreach (string ip in ipv4Input) 
{
    address = ip.Split(".", StringSplitOptions.RemoveEmptyEntries);
```
6. Удалите ссылки на string.Split из каждого метода проверки, чтобы вместо них использовалась глобальная переменная address. Например:
```cs
void ValidateLength() 
{
    validLength = address.Length == 4;
};
```
### Проверьте свою работу
1. Сравните свой код с приведенным ниже, чтобы убедиться в его правильности:
```cs
string[] ipv4Input = {"107.31.1.5", "255.0.0.255", "555..0.555", "255...255"};
string[] address;
bool validLength = false;
bool validZeroes = false;
bool validRange = false;

foreach (string ip in ipv4Input) 
{
    address = ip.Split(".", StringSplitOptions.RemoveEmptyEntries);

    ValidateLength(); 
    ValidateZeroes(); 
    ValidateRange();

    if (validLength && validZeroes && validRange) 
    {
        Console.WriteLine($"{ip} is a valid IPv4 address");
    } 
    else 
    {
        Console.WriteLine($"{ip} is an invalid IPv4 address");
    }
}

void ValidateLength() 
{
    validLength = address.Length == 4;
};

void ValidateZeroes() 
{
    foreach (string number in address) 
    {
        if (number.Length > 1 && number.StartsWith("0")) 
        {
            validZeroes = false;
            return;
        }
    }

    validZeroes = true;
}

void ValidateRange() 
{
    foreach (string number in address) 
    {
        int value = int.Parse(number);
        if (value < 0 || value > 255) 
        {
            validRange = false;
            return;
        }
    }
    validRange = true;
}
```
2. Запустите свой код и проверьте что вывод соотвествует
```
107.31.1.5 is a valid IPv4 address
255.0.0.255 is a valid IPv4 address
555..0.555 is an invalid IPv4 address
255...255 is an invalid IPv4 address
```
Если ваш код показывает другие результаты, вам нужно пересмотреть код, чтобы найти ошибку и внести обновления. Запустите код снова, чтобы проверить, устранили ли вы проблему. Продолжайте обновлять и запускать код до тех пор, пока он не даст ожидаемые результаты.

### Резюме
- Методы могут использоваться для быстрого структурирования приложений
- Ключевое слово `return` может использоваться для завершения выполнения метода
- Каждый этап решения задачи часто может быть преобразован в отдельный метод
- Используйте методы для решения небольших проблем, чтобы построить свое решение

## Общее задание по созданию многократно используемого метода

### Расскажите судьбу  

Вы помогаете разработать массовую многопользовательскую ролевую игру. У каждого игрока есть показатель удачи, который может повлиять на его шансы найти редкие сокровища. Каждый день игрок может поговорить с внутриигровым предсказателем, который покажет, какой у него показатель удачи - высокий, низкий или нейтральный.  

В настоящее время в игре есть код для генерации предсказаний, но он не пригоден для повторного использования. Ваша задача - создать метод `tellFortune`, который можно вызвать в любой момент, и заменить существующую логику вызовом вашего метода.  

В этой задаче вам дается стартовый код. Вы должны решить, как создать и вызвать метод `tellFortune`.

### Задача кода: создать метод многократного использования  

В коде, с которого вы начинаете, есть массив общего текста, за которым следуют массивы хорошего, плохого и нейтрального текста. В зависимости от значения параметра `luck` выбирается один из массивов и отображается рядом с общим текстом.  

Ваша задача - создать многократно используемый метод, который в любой момент выводит значение удачи игрока. Метод должен содержать логику, которая уже присутствует в представленном коде.  

1. Убедитесь, что в Visual Studio открыт пустой файл Program.cs. 
2. Скопируйте и вставьте в редактор следующий код:
```cs
Random random = new Random();
int luck = random.Next(100);

string[] text = {"You have much to", "Today is a day to", "Whatever work you do", "This is an ideal time to"};
string[] good = {"look forward to.", "try new things!", "is likely to succeed.", "accomplish your dreams!"};
string[] bad = {"fear.", "avoid major decisions.", "may have unexpected outcomes.", "re-evaluate your life."};
string[] neutral = {"appreciate.", "enjoy time with friends.", "should align with your values.", "get in tune with nature."};

Console.WriteLine("A fortune teller whispers the following words:");
string[] fortune = (luck > 75 ? good : (luck < 25 ? bad : neutral));
for (int i = 0; i < 4; i++) 
{
    Console.Write($"{text[i]} {fortune[i]} ");
}
```
3. Обновите код, чтобы использовать метод для отображения удачи. Используйте то, что вы узнали о создании и вызове методов, чтобы завершить обновление.
4. Проверьте свой код, изменив значение параметра `luck` и снова вызвав метод.
5. Убедитесь, что ваш код выдает одно из следующих сообщений:
```
A fortune teller whispers the following words:
You have much to look forward to. Today is a day to try new things! Whatever work you do is likely to succeed. This is an ideal time to accomplish your dreams!
```
```
A fortune teller whispers the following words:
You have much to appreciate. Today is a day to enjoy time with friends. Whatever work you do should align with your values. This is an ideal time to get in tune with nature.
```
```
A fortune teller whispers the following words:
You have much to fear. Today is a day to avoid major decisions. Whatever work you do may have unexpected outcomes. This is an ideal time to re-evaluate your life.
```

## Заключение
Ваша цель состояла в том, чтобы научиться создавать собственные методы для выполнения конкретных задач. Вы научились переносить многократно используемый код в методы, чтобы свести к минимуму повторение кода. Вы также научились использовать псевдокод и методы-заместители для решения сложных задач. Создавая небольшие методы с определенными обязанностями, вы научились быстро находить решения проблем с помощью эффективного и читабельного кода.