# Переменные и выражения в C#.

## 1. Введение

### 1.1 Значение переменных и выражений в программировании

---

#### 1.1.1 Краткое определение переменной

Переменная в программировании представляет собой именованный контейнер, используемый для хранения данных. В отличие от математических переменных, которые обычно представляют собой неизвестные значения, переменные в программировании хранят конкретные значения, которые могут изменяться в процессе выполнения программы. 

**Пример:**
```csharp
int age = 25;
```
Здесь `int` — это тип данных, `age` — имя переменной, а `25` — значение, которое хранится в переменной `age`.

В данном примере переменная `age` хранит целое число (25). В процессе выполнения программы значение этой переменной может изменяться, отражая, например, возраст пользователя, вводимый через интерфейс программы.

#### 1.1.2 Объяснение важности переменных в написании программ

Переменные являются фундаментальной концепцией в программировании, так как они позволяют программам хранить, передавать и изменять данные во время их выполнения. Без переменных практически невозможно создать полезную программу, так как она не сможет динамически оперировать данными, а значит, не сможет адаптироваться к изменяющимся условиям и вводимым данным.

Переменные позволяют программам:
- **Сохранять данные**: Например, пользователь может ввести своё имя, и программа сохранит его в переменной.
- **Передавать данные между различными частями программы**: Данные, хранящиеся в переменных, могут быть использованы в различных функциях и методах, что обеспечивает гибкость и повторное использование кода.
- **Изменять данные**: Программы могут модифицировать значения переменных в процессе выполнения, что позволяет им адаптироваться к изменениям во внешней среде или на основе результатов вычислений.

**Пример:**
```csharp
int age = 25;
age = age + 1;
```
Здесь переменная `age` сначала инициализируется значением `25`, а затем ее значение увеличивается на 1. Эта способность изменять данные на лету является ключевым аспектом динамичного программирования.

#### 1.1.3 Определение выражений и их роль в программировании

Выражение в программировании — это комбинация операндов (например, переменных, значений) и операторов (например, арифметических, логических), которая вычисляет и возвращает некоторое значение. Выражения могут быть простыми или сложными и используются в программах для выполнения вычислений, принятия решений и управления потоками выполнения.

**Пример:**
```csharp
int result = (10 + 5) * 2;
```
В данном примере `(10 + 5) * 2` — это выражение, состоящее из двух операндов `10` и `5`, оператора сложения `+`, оператора умножения `*`, и круглых скобок, определяющих порядок операций. Выражение вычисляется и возвращает значение `30`, которое затем сохраняется в переменной `result`.

Роль выражений в программировании:

1. **Вычисление значений**: Основная задача выражений — вычислять значения на основе данных и операторов.
   
2. **Управление потоком выполнения**: В условных операторах и циклах выражения используются для определения условий, на основе которых принимаются решения или повторяются действия.
   
3. **Обработка данных**: С помощью выражений программа может манипулировать данными, преобразовывать их и передавать результаты между различными компонентами.

**Пример использования выражения в условном операторе:**
```csharp
int age = 18;
if (age >= 18)
{
    Console.WriteLine("Вы совершеннолетний.");
}
else
{
    Console.WriteLine("Вы несовершеннолетний.");
}
```
Здесь `age >= 18` — это логическое выражение, которое возвращает `true` или `false` в зависимости от значения переменной `age`. На основе результата этого выражения программа определяет, какое сообщение вывести.

Таким образом, переменные и выражения являются основными строительными блоками программ. Переменные обеспечивают хранение и манипуляцию данными, а выражения позволяют выполнять вычисления и принимать решения, делая программу динамичной и интерактивной.

### 1.2 Обзор синтаксиса C#

---

#### 1.2.1 Общие принципы синтаксиса языка

Синтаксис языка программирования C# определяет правила и структуры, по которым должны быть написаны программы, чтобы их можно было скомпилировать и исполнить. В отличие от естественного языка, синтаксис C# строго формализован и однозначен, что позволяет избежать неопределенностей при интерпретации кода.

**Основные принципы синтаксиса C#:**

1. **Структурированность и блоки кода:**
   - Код в C# структурируется в виде блоков, которые обозначаются фигурными скобками `{}`. Это относится как к определению классов и методов, так и к условным конструкциям, циклам и другим элементам языка. Например:
     ```csharp
     if (condition)
     {
         // Блок кода выполняется, если условие истинно
     }
     else
     {
         // Блок кода выполняется, если условие ложно
     }
     ```
   - Такой подход обеспечивает четкую организацию кода, где каждый блок логически завершен и ограничен.

2. Чувствительность к регистру:
   - C# является регистрозависимым языком. Это означает, что идентификаторы с разными регистрами символов считаются разными. Например, переменные `myVariable` и `MyVariable` — это два разных идентификатора:
     ```csharp
     int myVariable = 10;
     int MyVariable = 20;
     ```

3. Завершение инструкций точкой с запятой
   - Каждая инструкция в C# должна заканчиваться точкой с запятой `;`. Это позволяет компилятору различать завершенные команды и понимать, где заканчивается одна инструкция и начинается другая:
     ```csharp
     int x = 5;
     int y = 10;
     int sum = x + y;
     ```
   - Нарушение этого правила приведет к синтаксической ошибке.

4. Использование ключевых слов
   - C# имеет набор ключевых слов, которые имеют специальное значение и зарезервированы для использования в языке. Например, `int`, `class`, `if`, `else` и др. Эти ключевые слова нельзя использовать в качестве имен переменных или других идентификаторов:
     ```csharp
     class MyClass
     {
         int myVariable = 5;
     }
     ```
   - Ключевые слова определяют основные конструкции языка и его элементы.

5. Комментарии
   - C# поддерживает два вида комментариев: однострочные и многострочные. Комментарии используются для добавления пояснений в код, которые игнорируются компилятором и не влияют на выполнение программы:
     - **Однострочные комментарии:** начинаются с `//`
       ```csharp
       // Это однострочный комментарий
       int x = 10; // Инициализация переменной
       ```
     - **Многострочные комментарии:** заключаются между `/*` и `*/`
       ```csharp
       /* Это
          многострочный
          комментарий */
       int y = 20;
       ```

#### 1.2.2 Введение в типизацию языка (статическая типизация)

C# является строго типизированным языком программирования с поддержкой статической типизации. Это означает, что каждый объект в программе имеет определенный тип, который компилятор проверяет на этапе компиляции, а не во время выполнения программы. В случае несоответствия типов компилятор выдаст ошибку, что предотвращает многие потенциальные ошибки на ранних этапах разработки.

**Основные особенности статической типизации в C#:**

1. **Объявление типов переменных:**
   - При объявлении переменной в C# необходимо явно указать её тип. Например, если переменная будет хранить целое число, необходимо использовать тип `int`, если строку — `string` и т.д.:
     ```csharp
     int age = 25;    // Целое число
     string name = "John";  // Строка
     ```
   - Это позволяет компилятору проверять, соответствуют ли значения, присваиваемые переменным, их объявленным типам.

2. **Преимущества статической типизации:**
   - **Раннее обнаружение ошибок:** Компилятор проверяет типы на этапе компиляции, что позволяет обнаружить и исправить ошибки до выполнения программы.
   - **Улучшенная производительность:** Так как типы известны заранее, компилятор может оптимизировать код и улучшить его производительность.
   - **Ясность кода:** Явное указание типов делает код более понятным и легко поддерживаемым, поскольку сразу видно, какие данные предполагается использовать.

3. **Система типов C#:**
   - C# поддерживает как **простые типы данных** (например, `int`, `double`, `bool`), так и **ссылочные типы** (например, `string`, массивы, классы). Например:
     ```csharp
     double pi = 3.14159;  // Вещественное число
     bool isAdult = true;  // Логическое значение
     ```
   - Также поддерживаются **nullable типы**, которые позволяют переменным принимать значение `null` (например, `int?`):
     ```csharp
     int? nullableInt = null;  // Переменная, которая может быть null
     ```

4. **Операции приведения типов:**
   - В C# существуют как **неявное приведение** (например, от `int` к `double`), так и **явное приведение** (например, от `double` к `int`), которое требует использования оператора приведения:
     ```csharp
     double num = 5.5;
     int roundedNum = (int)num;  // Явное приведение от double к int
     ```
   - Ошибки приведения типов могут быть обнаружены на этапе компиляции, что снижает вероятность ошибок времени выполнения.

**Пример с использованием статической типизации:**
```csharp
int a = 10;
double b = 5.5;
double result = a + b;  // a автоматически приводится к double

string text = "Result is: ";
Console.WriteLine(text + result);
```
В этом примере переменные `a` и `b` имеют разные типы (`int` и `double` соответственно). При выполнении операции сложения `a` неявно приводится к типу `double`, чтобы результат соответствовал типу `result`. 

Таким образом, статическая типизация в C# помогает разработчикам писать более безопасный и оптимизированный код, который легко поддерживать и развивать. Она служит основой для надежного и предсказуемого поведения программ, что особенно важно в крупных и сложных программных проектах.

---

## 2. Переменные в C#

### 2.1 Определение переменной

---

#### 2.1.1 Что такое переменная: контейнер для хранения данных

Переменная в языке программирования C# представляет собой именованный элемент, предназначенный для хранения данных определенного типа. В программировании переменные служат в качестве временного контейнера для данных, которые могут изменяться в ходе выполнения программы. Эти данные могут быть разного типа, например, числа, строки, логические значения и т.д.

Каждая переменная ассоциируется с определенным типом данных, который определяет объем памяти, необходимый для хранения данных, а также набор операций, допустимых для этого типа.

**Пример:**
```csharp
int number = 10;
string greeting = "Hello, world!";
bool isStudent = true;
```

В данном примере:
- `number` — переменная типа `int`, которая хранит целое число `10`.
- `greeting` — переменная типа `string`, хранящая строку `"Hello, world!"`.
- `isStudent` — переменная типа `bool`, хранящая логическое значение `true`.

Переменные в C# могут быть изменены в процессе выполнения программы, что позволяет создавать динамичные и интерактивные приложения.

**Роль переменных:**
1. **Сохранение данных:** Переменные сохраняют данные, которые могут быть использованы многократно в ходе работы программы.
2. **Изменение данных:** Переменные позволяют изменять данные, например, при изменении состояния приложения.
3. **Передача данных:** Переменные используются для передачи значений между различными методами и классами программы.

#### 2.1.2 Правила именования переменных (CamelCase, PascalCase, использование латинских букв, запрет на использование ключевых слов)

Правильное именование переменных в C# играет важную роль в поддержке читабельности и удобства сопровождения кода. Существует несколько общепринятых соглашений и правил, которых следует придерживаться при выборе имен для переменных.

**1. CamelCase и PascalCase:**

- **CamelCase:** В этом стиле имя переменной начинается с маленькой буквы, а каждое следующее слово начинается с заглавной буквы. Такой стиль используется для именования локальных переменных и параметров методов.
  - **Пример:**
    ```csharp
    int studentAge = 20;
    string firstName = "John";
    bool isEnrolled = true;
    ```

- **PascalCase:** В этом стиле имя переменной начинается с заглавной буквы, как и каждое следующее слово. PascalCase используется для именования публичных полей, свойств, методов и классов.
  - **Пример:**
    ```csharp
    public int StudentAge { get; set; }
    public string FirstName { get; set; }
    public bool IsEnrolled { get; set; }
    ```

Эти соглашения позволяют легко различать типы переменных и членов класса, что способствует более структурированному и понятному коду.

**2. Использование латинских букв:**

- В C# для именования переменных следует использовать символы латинского алфавита (`A-Z`, `a-z`), цифры (`0-9`), а также символ подчеркивания (`_`). 
- Имя переменной не может начинаться с цифры, однако может содержать цифры внутри.
  - **Пример:**
    ```csharp
    int count123 = 123;    // Допустимо
    int 123count = 456;    // Ошибка: имя не может начинаться с цифры
    ```

**3. Запрет на использование ключевых слов:**

- В C# существует набор ключевых слов, зарезервированных для использования языком. Эти слова выполняют специальные функции и не могут быть использованы в качестве имен переменных, так как это вызовет синтаксическую ошибку.
  - Примеры ключевых слов: `int`, `class`, `if`, `else`, `for`, `while`, `return`, `true`, `false` и т.д.
  - **Пример ошибки:**
    ```csharp
    int int = 10;  // Ошибка: "int" является ключевым словом
    ```

- В случаях, когда все же необходимо использовать имя, совпадающее с ключевым словом, можно применить символ `@` перед именем переменной. Однако такой подход не рекомендуется, так как он может сделать код менее читаемым.
  - **Пример:**
    ```csharp
    int @class = 20;  // Допустимо, но не рекомендуется
    ```

**4. Другие рекомендации по именованию переменных:**

- **Читаемость и смысловая нагрузка:** Имена переменных должны быть осмысленными и отражать данные, которые они хранят. Это улучшает читаемость кода и упрощает его поддержку.
  - **Пример:**
    ```csharp
    // Плохая практика:
    int x = 10;

    // Хорошая практика:
    int studentAge = 10;
    ```

- **Использование символа подчеркивания `_`:** Символ подчеркивания может использоваться для разделения слов в имени переменной, однако в C# это не принято для имен локальных переменных и полей (кроме приватных полей, где символ `_` используется в некоторых соглашениях).
  - **Пример:**
    ```csharp
    private int _studentAge;  // Допустимо для приватного поля
    ```

Таким образом, соблюдение правил именования переменных в C# не только помогает избежать синтаксических ошибок, но и способствует созданию ясного и поддерживаемого кода. Хорошо продуманные имена переменных значительно облегчают процесс разработки, тестирования и сопровождения программного обеспечения.

### 2.2 Типы данных в C#

#### **Простые типы данных**

---

В языке программирования C# типы данных играют ключевую роль, определяя свойства переменных и возможные операции над ними. Простые типы данных (или примитивные типы) представляют собой фундаментальные типы, встроенные в язык, которые широко используются для хранения значений различных категорий, таких как целые числа, вещественные числа, символы и логические значения. Рассмотрим каждую категорию подробнее.

---

##### 2.2.1 Целые числа (int, long, byte и т.д.)

Целые числа в C# используются для хранения числовых значений без дробной части. В зависимости от размера и диапазона значений, в языке представлены несколько типов для хранения целых чисел:

1. **`int` (integer):**
   - Размер: 32 бита.
   - Диапазон: от -2,147,483,648 до 2,147,483,647.
   - Используется для хранения чисел среднего размера.
   - **Пример:**
     ```csharp
     int age = 25;
     int population = 1000000;
     ```

2. **`long` (long integer):**
   - Размер: 64 бита.
   - Диапазон: от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.
   - Применяется для хранения больших чисел, которые выходят за пределы типа `int`.
   - **Пример:**
     ```csharp
     long distanceToSun = 150000000000L;  // Расстояние в километрах
     long worldPopulation = 7800000000L;
     ```

3. **`short` (short integer):**
   - Размер: 16 бит.
   - Диапазон: от -32,768 до 32,767.
   - Используется для экономии памяти в случаях, когда гарантировано небольшое числовое значение.
   - **Пример:**
     ```csharp
     short temperature = -20;
     short speedLimit = 120;
     ```

4. **`byte`:**
   - Размер: 8 бит.
   - Диапазон: от 0 до 255.
   - Применяется для хранения небольших положительных целых чисел, часто используется для работы с данными в бинарном формате.
   - **Пример:**
     ```csharp
     byte age = 25;
     byte maxByteValue = 255;
     ```

5. **`sbyte` (signed byte):**
   - Размер: 8 бит.
   - Диапазон: от -128 до 127.
   - Используется для хранения небольших целых чисел с возможностью отрицательных значений.
   - **Пример:**
     ```csharp
     sbyte temperature = -5;
     sbyte smallNumber = 100;
     ```

**Роль целочисленных типов:**
Целочисленные типы данных широко используются в программировании для счетчиков, индексов, хранения значений времени, финансовых расчётов и других областей, где не требуется дробная часть числа.

---

##### 2.2.2 Вещественные числа (float, double, decimal)

Вещественные (или дробные) числа включают в себя целую и дробную части. C# предоставляет несколько типов данных для работы с такими числами, каждый из которых имеет свои особенности в плане точности и диапазона.

1. **`float` (single precision floating point):**
   - Размер: 32 бита.
   - Диапазон: приблизительно от 1.5 × 10^−45 до 3.4 × 10^38.
   - Точность: 7 значащих цифр.
   - Используется для хранения чисел с плавающей запятой, где требуется экономия памяти.
   - **Пример:**
     ```csharp
     float pi = 3.14159f;
     float gravity = 9.8f;
     ```

2. **`double` (double precision floating point):**
   - Размер: 64 бита.
   - Диапазон: приблизительно от 5.0 × 10^−324 до 1.7 × 10^308.
   - Точность: 15-16 значащих цифр.
   - Используется по умолчанию для вещественных чисел в C# и подходит для большинства вычислений.
   - **Пример:**
     ```csharp
     double e = 2.718281828459045;
     double distance = 384400.0;  // Расстояние до Луны в километрах
     ```

3. **`decimal`:**
   - Размер: 128 бит.
   - Диапазон: приблизительно от ±1.0 × 10^−28 до ±7.9228 × 10^28.
   - Точность: 28-29 значащих цифр.
   - Предназначен для финансовых и денежных вычислений, где важна высокая точность, особенно в случае малых дробных значений.
   - **Пример:**
     ```csharp
     decimal price = 19.99m;
     decimal largeAmount = 1000000.123456789m;
     ```

**Особенности работы с вещественными числами:**
- Вещественные числа не всегда могут быть точно представлены в памяти, особенно при использовании типов `float` и `double`, что может привести к погрешностям в вычислениях.
- Тип `decimal` предпочтителен для финансовых операций из-за его высокой точности при работе с дробными числами.

---

##### 2.2.3 Символьные данные (char)

Тип данных `char` в C# используется для хранения отдельных символов. Символы представляют собой одиночные текстовые элементы, такие как буквы, цифры, знаки пунктуации и другие символы Unicode.

1. **`char`:**
   - Размер: 16 бит.
   - Диапазон: от `\u0000` до `\uFFFF` (это диапазон символов Unicode).
   - Каждый символ заключается в одинарные кавычки.
   - **Пример:**
     ```csharp
     char letter = 'A';
     char digit = '1';
     char symbol = '#';
     ```

**Особенности типа `char`:**
- `char` используется для представления и манипуляции отдельными символами.
- Тип `char` может быть полезен при работе с текстом, парсинге строк и кодировке символов.

**Пример с использованием типа `char`:**
```csharp
char initial = 'J';
Console.WriteLine("Your initial is: " + initial);
```

---

##### 2.2.4 Логический тип (bool)

Логический тип данных `bool` в C# предназначен для хранения одного из двух возможных значений: `true` (истина) или `false` (ложь). Этот тип данных используется в основном для управления логикой выполнения программ.

1. **`bool`:**
   - Размер: 1 байт (но конкретный размер зависит от платформы).
   - Возможные значения: `true` или `false`.
   - **Пример:**
     ```csharp
     bool isAlive = true;
     bool hasPassed = false;
     ```

**Роль логического типа:**
- Логические переменные часто используются в условных операторах, таких как `if`, `while`, и `for`, чтобы контролировать поток выполнения программы.
- Логические выражения также могут включать операции сравнения и логические операции, такие как `&&` (и), `||` (или), и `!` (не).

**Пример использования логического типа:**
```csharp
bool isEven = (number % 2 == 0);
if (isEven)
{
    Console.WriteLine("Number is even.");
}
else
{
    Console.WriteLine("Number is odd.");
}
```

В этом примере переменная `isEven` принимает значение `true` или `false` в зависимости от того, является ли число четным или нечетным, что затем используется в условной конструкции.

---

Таким образом, простые типы данных в C# предоставляют широкий спектр возможностей для представления и обработки различных видов данных. Выбор конкретного типа данных зависит от требований программы, таких как необходимый диапазон значений, требуемая точность вычислений, а также потребление памяти. Использование правильного типа данных позволяет писать более эффективные и производительные программы.

#### Ссылочные типы

---

Ссылочные типы данных в C# представляют собой типы, значения которых хранятся в памяти в виде ссылок на объекты. Это означает, что переменные ссылочных типов не содержат сами данные напрямую, а лишь указывают на место в памяти, где эти данные находятся. Среди основных ссылочных типов в C# можно выделить строки, массивы и классы (объекты).

---

##### 2.2.1 Строки (string)

**Строки** — это один из самых часто используемых ссылочных типов данных в C#. Строки представляют собой последовательности символов (типов `char`), которые объединены в одно значение. В C# строки являются неизменяемыми, что означает, что после создания строки её значение нельзя изменить; любые операции, изменяющие строку, создают новую строку.

1. **`string`:**
   - **Описание:** Тип данных `string` используется для хранения текстовой информации.
   - **Хранение:** Значение строки хранится как последовательность символов в памяти, на которую указывает ссылка.
   - **Неизменяемость:** Любые операции, изменяющие строку, на самом деле создают новый объект `string`.
   - **Пример:**
     ```csharp
     string greeting = "Hello, world!";
     string name = "John Doe";
     ```

**Особенности работы со строками:**

- **Конкатенация:** Объединение двух или более строк с помощью оператора `+` или метода `Concat`.
  - **Пример:**
    ```csharp
    string firstName = "John";
    string lastName = "Doe";
    string fullName = firstName + " " + lastName;  // "John Doe"
    ```

- **Индексация:** Доступ к отдельным символам строки с помощью индексов (начиная с 0).
  - **Пример:**
    ```csharp
    char firstLetter = greeting[0];  // 'H'
    ```

- **Методы строк:** C# предоставляет множество встроенных методов для работы со строками, таких как `Substring`, `IndexOf`, `ToUpper`, `ToLower`, `Replace` и другие.
  - **Пример:**
    ```csharp
    string upperGreeting = greeting.ToUpper();  // "HELLO, WORLD!"
    string substring = greeting.Substring(7, 5);  // "world"
    ```

- **Интернирование строк:** C# поддерживает механизм интернирования строк, при котором одинаковые строковые литералы указывают на один и тот же объект в памяти для экономии ресурсов.

Строки в C# являются мощным инструментом для обработки текстовых данных, и благодаря множеству встроенных методов и операторов, работа с ними является простой и интуитивной.

---

##### 2.2.2 Массивы

Массивы — это структура данных, которая позволяет хранить несколько элементов одного типа под общим именем. В C# массивы являются ссылочным типом, и их элементы хранятся в последовательных ячейках памяти, доступ к которым осуществляется по индексу.

1. **Описание массивов:**
   - **Статический размер:** Размер массива задается при его создании и не может быть изменен в дальнейшем.
   - **Тип данных:** Массив может содержать элементы только одного типа данных, будь то примитивные или ссылочные типы.
   - **Инициализация:** Массив может быть инициализирован сразу при объявлении или позже.
   - **Пример:**
     ```csharp
     int[] numbers = new int[5];  // Массив на 5 элементов
     numbers[0] = 10;
     numbers[1] = 20;
     numbers[2] = 30;
     numbers[3] = 40;
     numbers[4] = 50;
     ```

2. **Индексация массивов:**
   - Элементы массива доступны через индексы, которые начинаются с 0 и заканчиваются на `Length - 1`, где `Length` — это количество элементов в массиве.
   - **Пример:**
     ```csharp
     int firstElement = numbers[0];  // 10
     int lastElement = numbers[numbers.Length - 1];  // 50
     ```

3. **Инициализация массивов:**
   - Массивы могут быть инициализированы сразу при объявлении с помощью литералов массива.
   - **Пример:**
     ```csharp
     int[] primes = { 2, 3, 5, 7, 11 };
     ```

4. **Многомерные массивы:**
   - C# поддерживает многомерные массивы, такие как двумерные (матрицы) и трехмерные массивы.
   - **Пример:**
     ```csharp
     int[,] matrix = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };
     int element = matrix[0, 2];  // 3
     ```

5. **Ступенчатые массивы:**
   - Это массивы массивов, где каждый внутренний массив может иметь разную длину.
   - **Пример:**
     ```csharp
     int[][] jaggedArray = new int[2][];
     jaggedArray[0] = new int[] { 1, 2 };
     jaggedArray[1] = new int[] { 3, 4, 5 };
     ```

Массивы в C# являются важным инструментом для хранения и управления множеством данных, позволяя быстро и эффективно получать доступ к элементам по индексу.

---

##### 2.2.3 Классы и объекты

Классы и объекты представляют собой основополагающие элементы объектно-ориентированного программирования (ООП) в C#. Класс — это определение или шаблон, по которому создаются объекты. Объект — это конкретный экземпляр класса, содержащий данные (свойства) и поведение (методы).

1. **Классы:**
   - **Описание:** Класс — это пользовательский тип данных, который определяет структуру объектов. Он может включать поля (данные), методы (функции), свойства, события и другие элементы.
   - **Пример:**
     ```csharp
     public class Person
     {
         public string Name { get; set; }
         public int Age { get; set; }

         public void Introduce()
         {
             Console.WriteLine($"Hello, my name is {Name} and I am {Age} years old.");
         }
     }
     ```

2. **Объекты:**
   - **Описание:** Объект — это экземпляр класса, который создается в памяти с помощью ключевого слова `new`. Объекты имеют доступ к данным и методам класса, от которого они были созданы.
   - **Пример создания объекта:**
     ```csharp
     Person person = new Person();
     person.Name = "John";
     person.Age = 30;
     person.Introduce();  // "Hello, my name is John and I am 30 years old."
     ```

3. **Инкапсуляция:**
   - **Описание:** Инкапсуляция — это принцип ООП, позволяющий скрывать детали реализации и предоставлять доступ только к необходимым данным и методам через интерфейсы (свойства и методы класса).
   - **Пример:**
     ```csharp
     public class BankAccount
     {
         private decimal balance;

         public void Deposit(decimal amount)
         {
             balance += amount;
         }

         public decimal GetBalance()
         {
             return balance;
         }
     }
     ```

4. **Наследование:**
   - **Описание:** Наследование позволяет создавать новые классы на основе существующих, наследуя их свойства и методы.
   - **Пример:**
     ```csharp
     public class Animal
     {
         public string Name { get; set; }
         public void Eat() { Console.WriteLine($"{Name} is eating."); }
     }

     public class Dog : Animal
     {
         public void Bark() { Console.WriteLine($"{Name} is barking."); }
     }

     Dog dog = new Dog();
     dog.Name = "Buddy";
     dog.Eat();  // "Buddy is eating."
     dog.Bark(); // "Buddy is barking."
     ```

5. **Полиморфизм:**
   - **Описание:** Полиморфизм позволяет использовать методы и свойства классов на основе их общего интерфейса, что повышает гибкость и расширяемость кода.
   - **Пример:**
     ```csharp
     public class Shape
     {
         public virtual void Draw() { Console.WriteLine("Drawing a shape."); }
     }

     public class Circle : Shape
     {
         public override void Draw() { Console.WriteLine("Drawing a circle."); }
     }

     public class Square : Shape
     {
         public override void Draw() { Console.WriteLine("Drawing a square."); }
     }

     Shape shape = new Circle();
     shape.Draw();  // "Drawing a circle."

     shape = new Square();
     shape.Draw();  // "Drawing a square."
     ```

6. **Абстракция:**
   - **Описание:** Абстракция — это принцип ООП, который позволяет создавать абстрактные классы и интерфейсы, определяющие общий интерфейс для классов-наследников. Абстрактный класс не может быть инстанцирован напрямую и служит основой для создания конкретных классов.
   - **Пример:**
     ```csharp
     public abstract class Animal
     {
         public string Name { get; set; }
         public abstract void MakeSound();  // Абстрактный метод

         public void Eat() 
         {
             Console.WriteLine($"{Name} is eating.");
         }
     }

     public class Dog : Animal
     {
         public override void MakeSound() 
         {
             Console.WriteLine("Bark");
         }
     }

     public class Cat : Animal
     {
         public override void MakeSound() 
         {
             Console.WriteLine("Meow");
         }
     }

     Dog dog = new Dog();
     dog.Name = "Buddy";
     dog.MakeSound();  // "Bark"
     dog.Eat();        // "Buddy is eating."

     Cat cat = new Cat();
     cat.Name = "Whiskers";
     cat.MakeSound();  // "Meow"
     cat.Eat();        // "Whiskers is eating."
     ```

   В этом примере класс `Animal` является абстрактным и содержит абстрактный метод `MakeSound`, который должен быть реализован в классах-наследниках. Конкретные классы `Dog` и `Cat` предоставляют свои реализации метода `MakeSound`, демонстрируя принцип абстракции.

7. **Интерфейсы:**
   - **Описание:** Интерфейсы в C# определяют набор методов и свойств, которые должны быть реализованы в классах, реализующих данный интерфейс. Интерфейсы не содержат реализации методов, а лишь их сигнатуры.
   - **Пример:**
     ```csharp
     public interface IFlyable
     {
         void Fly();
     }

     public class Bird : IFlyable
     {
         public void Fly()
         {
             Console.WriteLine("Bird is flying.");
         }
     }

     public class Airplane : IFlyable
     {
         public void Fly()
         {
             Console.WriteLine("Airplane is flying.");
         }
     }

     IFlyable flyingObject = new Bird();
     flyingObject.Fly();  // "Bird is flying."

     flyingObject = new Airplane();
     flyingObject.Fly();  // "Airplane is flying."
     ```

   В данном примере интерфейс `IFlyable` определяет метод `Fly`. Классы `Bird` и `Airplane` реализуют этот интерфейс, предоставляя свою версию метода `Fly`. Переменная `flyingObject` типа `IFlyable` может хранить ссылку на любой объект, который реализует этот интерфейс, демонстрируя гибкость и мощь полиморфизма.

8. **Конструкторы:**
   - **Описание:** Конструкторы — это специальные методы, которые вызываются при создании объекта класса. Конструкторы инициализируют состояние объекта и могут принимать параметры для настройки начальных значений.
   - **Пример:**
     ```csharp
     public class Car
     {
         public string Make { get; set; }
         public string Model { get; set; }
         public int Year { get; set; }

         // Конструктор по умолчанию
         public Car() 
         {
             Make = "Unknown";
             Model = "Unknown";
             Year = 2000;
         }

         // Параметризованный конструктор
         public Car(string make, string model, int year)
         {
             Make = make;
             Model = model;
             Year = year;
         }

         public void DisplayInfo()
         {
             Console.WriteLine($"{Year} {Make} {Model}");
         }
     }

     Car defaultCar = new Car();
     defaultCar.DisplayInfo();  // "2000 Unknown Unknown"

     Car specificCar = new Car("Toyota", "Camry", 2020);
     specificCar.DisplayInfo();  // "2020 Toyota Camry"
     ```

   В этом примере класс `Car` имеет два конструктора: конструктор по умолчанию и параметризованный конструктор, который позволяет создавать объекты с различными начальными значениями.

9. **Деструкторы:**
   - **Описание:** Деструкторы (или финализаторы) — это методы, которые вызываются перед уничтожением объекта для освобождения ресурсов, которые объект мог использовать. В C# деструкторы редко используются, так как сборка мусора (garbage collection) автоматически управляет памятью.
   - **Пример:**
     ```csharp
     public class Resource
     {
         // Конструктор
         public Resource() 
         {
             Console.WriteLine("Resource allocated.");
         }

         // Деструктор
         ~Resource()
         {
             Console.WriteLine("Resource deallocated.");
         }
     }

     // Пример использования
     void Main()
     {
         Resource resource = new Resource();
         // Resource будет уничтожен, когда программа завершится, или когда сборщик мусора освободит память
     }
     ```

   В этом примере деструктор в классе `Resource` освобождает ресурсы, когда объект уничтожается. Важно отметить, что порядок и время вызова деструктора не гарантированы, так как это зависит от работы сборщика мусора.

10. **Копирование объектов:**
    - **Описание:** В C# существуют два способа копирования объектов: поверхностное (shallow copy) и глубокое копирование (deep copy). При поверхностном копировании копируются только ссылки на объекты, а при глубоком копировании создаются полные копии всех вложенных объектов.
    - **Пример:**
      ```csharp
      public class Address
      {
          public string City { get; set; }
          public string Street { get; set; }
      }

      public class Person
      {
          public string Name { get; set; }
          public Address Address { get; set; }

          // Поверхностное копирование
          public Person ShallowCopy()
          {
              return (Person)this.MemberwiseClone();
          }

          // Глубокое копирование
          public Person DeepCopy()
          {
              Person clone = (Person)this.MemberwiseClone();
              clone.Address = new Address { City = this.Address.City, Street = this.Address.Street };
              return clone;
          }
      }

      // Пример использования
      Person original = new Person { Name = "John", Address = new Address { City = "New York", Street = "5th Avenue" } };
      Person shallowCopy = original.ShallowCopy();
      Person deepCopy = original.DeepCopy();

      shallowCopy.Address.City = "Los Angeles";  // Меняет город в обеих копиях
      deepCopy.Address.City = "Chicago";  // Меняет город только в deepCopy
      ```

    В этом примере метод `ShallowCopy` создает поверхностную копию объекта, а метод `DeepCopy` создает глубокую копию, что важно, когда требуется полностью независимое копирование объектов.

Таким образом, классы и объекты в C# предоставляют мощный и гибкий механизм для моделирования сложных систем и процессов. Использование принципов объектно-ориентированного программирования, таких как инкапсуляция, наследование, полиморфизм и абстракция, позволяет создавать код, который легко поддерживать, расширять и повторно использовать.

##### 2.2.4 Nullable типы

---

###### **Использование Nullable типизации**

В языке программирования C# существует строгая система типизации, которая обеспечивает безопасность кода, предотвращая неправильное использование типов данных. Однако в некоторых ситуациях возникает необходимость работать с типами данных, которые могут содержать неопределенное или отсутствующее значение. В таких случаях используется механизм Nullable типов.

**Nullable типы** позволяют переменным типов значений (таких как `int`, `float`, `bool` и другие) принимать специальное значение `null`, которое обычно зарезервировано для ссылочных типов. Это полезно, когда необходимо указать, что значение переменной отсутствует или еще не было присвоено, что особенно важно при работе с базами данных, формами ввода и другими сценариями, где значения могут быть не определены.

###### **Общие концепции Nullable типов:**

1. **Nullable типы данных:**
   - В C# для создания Nullable типов используется специальный синтаксис с вопросительным знаком `?` после типа данных или класс `Nullable<T>`, где `T` — это тип значения. Например, `int?` и `Nullable<int>` представляют собой тип `int`, который может принимать значение `null`.
   - **Пример:**
     ```csharp
     int? nullableInt = null;
     Nullable<int> anotherNullableInt = 5;
     ```

   В этом примере `nullableInt` и `anotherNullableInt` могут содержать как целые числа, так и значение `null`. Использование Nullable типов делает код более гибким, позволяя учитывать случаи отсутствия данных.

2. **Nullable типизация и проверка на `null`:**
   - Для работы с Nullable типами и проверки, содержат ли они значение, используется свойство `HasValue` и метод `GetValueOrDefault`.
   - **Пример:**
     ```csharp
     int? score = 10;
     if (score.HasValue)
     {
         Console.WriteLine("Score is: " + score.Value);
     }
     else
     {
         Console.WriteLine("Score is not available.");
     }
     ```

   В этом коде переменная `score` проверяется на наличие значения с помощью свойства `HasValue`. Если `score` имеет значение, то доступ к нему осуществляется через свойство `Value`. Если значение отсутствует, выводится сообщение о недоступности данных.

3. **Операции с Nullable типами:**
   - С Nullable типами можно выполнять математические и логические операции так же, как и с обычными типами. Однако результат таких операций будет также Nullable, и если хотя бы один из операндов равен `null`, то результат будет `null`.
   - **Пример:**
     ```csharp
     int? a = 5;
     int? b = null;
     int? sum = a + b;  // sum будет равен null
     Console.WriteLine(sum.HasValue ? sum.ToString() : "No value");
     ```

   Здесь переменная `sum` будет равна `null`, поскольку одно из слагаемых (`b`) равно `null`. Это иллюстрирует, как операции с Nullable типами могут приводить к неопределенным результатам, что необходимо учитывать при разработке логики программы.

4. **Применение оператора объединения с `null` (`??`):**
   - C# предоставляет оператор объединения с `null` (`??`), который возвращает левый операнд, если он не равен `null`, и правый операнд в противном случае. Этот оператор полезен для назначения значений по умолчанию.
   - **Пример:**
     ```csharp
     int? nullableScore = null;
     int finalScore = nullableScore ?? 0;  // Если nullableScore равно null, то finalScore будет 0
     Console.WriteLine(finalScore);  // Вывод: 0
     ```

   В данном примере оператор `??` используется для присвоения переменной `finalScore` значения по умолчанию (0), если `nullableScore` равно `null`. Это обеспечивает безопасное управление значениями и упрощает обработку Nullable типов.

###### **Пример использования `int?` и `Nullable<int>`**

Рассмотрим несколько примеров, иллюстрирующих применение Nullable типов на практике.

1. **Пример с использованием `int?`:**
   ```csharp
   public class Program
   {
       public static void Main()
       {
           int? age = null;

           // Проверка на наличие значения
           if (age.HasValue)
           {
               Console.WriteLine($"Age is {age.Value}");
           }
           else
           {
               Console.WriteLine("Age is not provided.");
           }

           // Присвоение значения, если оно отсутствует
           age = age ?? 18;
           Console.WriteLine($"Assigned age: {age}");
       }
   }
   ```
   **Описание:**
   - В этом примере переменная `age` изначально имеет значение `null`, что означает, что возраст не указан.
   - Сначала выполняется проверка на наличие значения с помощью свойства `HasValue`. Если значение присутствует, оно выводится на экран, в противном случае выводится сообщение об отсутствии возраста.
   - Далее используется оператор объединения с `null` (`??`) для присвоения переменной `age` значения по умолчанию (18), если возраст не был указан.

2. **Пример с использованием `Nullable<int>`:**
   ```csharp
   public class Program
   {
       public static void Main()
       {
           Nullable<int> number = 42;

           // Вывод значения, если оно присутствует
           Console.WriteLine("Number: " + (number.HasValue ? number.Value.ToString() : "No number provided"));

           // Сброс значения на null
           number = null;
           Console.WriteLine("After reset: " + (number.HasValue ? number.Value.ToString() : "No number provided"));

           // Присвоение значения по умолчанию, если number равно null
           int result = number.GetValueOrDefault(-1);
           Console.WriteLine("Result: " + result);
       }
   }
   ```
   **Описание:**
   - В этом примере создается переменная `number` типа `Nullable<int>` и ей присваивается значение 42.
   - Затем с помощью тернарного оператора проверяется наличие значения и выводится либо значение переменной, либо сообщение о его отсутствии.
   - Переменная `number` затем сбрасывается на `null`, и снова проверяется наличие значения.
   - Наконец, используется метод `GetValueOrDefault`, чтобы получить значение переменной или вернуть -1, если `number` равно `null`.

В обоих примерах показано, как можно эффективно использовать Nullable типы для управления переменными, которые могут принимать значения `null`. Это обеспечивает более гибкую и надежную обработку данных в сценариях, где значения могут быть неопределенными.

### 2.3 Объявление и инициализация переменных

---

В C# переменные представляют собой именованные участки памяти, которые используются для хранения данных. Перед использованием переменной ее необходимо объявить и, в большинстве случаев, инициализировать. Объявление и инициализация переменных являются основополагающими операциями, обеспечивающими корректную работу программ.

#### **2.3.1 Объявление переменных: синтаксис**

**Объявление переменной** в C# включает указание типа данных переменной и имени переменной. Синтаксис объявления переменной следующий:

```csharp
тип_данных имя_переменной;
```

Где:
- **тип_данных** — это тип данных, который определяет, какие значения может хранить переменная (например, `int`, `string`, `bool`, `double` и т.д.).
- **имя_переменной** — это уникальный идентификатор, с помощью которого можно обращаться к переменной в коде.

**Пример:**
```csharp
int age;
string name;
bool isStudent;
```

В этом примере:
- Переменная `age` может хранить целое число.
- Переменная `name` может хранить строку.
- Переменная `isStudent` может хранить логическое значение (`true` или `false`).

Объявление переменной резервирует участок памяти под данные указанного типа, но не присваивает ей начального значения (если это не переменная ссылочного типа, которая по умолчанию инициализируется значением `null`). Если попытаться использовать необъявленную переменную, это приведет к ошибке компиляции.

**Важно отметить:**
- Переменные, объявленные внутри метода (локальные переменные), должны быть инициализированы перед использованием. Если попытаться использовать неинициализированную локальную переменную, это приведет к ошибке компиляции.
- Поля класса (переменные уровня класса) автоматически инициализируются значением по умолчанию (например, числовые типы — `0`, логические — `false`, ссылочные типы — `null`).

#### **2.3.2 Инициализация переменных: присвоение значений при объявлении**

**Инициализация переменной** — это процесс присвоения переменной начального значения. Инициализация может выполняться одновременно с объявлением переменной. Синтаксис инициализации переменной следующий:

```csharp
тип_данных имя_переменной = значение;
```

Где:
- **значение** — это данные, которые будут присвоены переменной и должны соответствовать указанному типу данных.

**Пример:**
```csharp
int age = 25;
string name = "John Doe";
bool isStudent = true;
double temperature = 36.6;
```

В этом примере:
- Переменной `age` сразу присваивается значение `25`.
- Переменной `name` присваивается строка `"John Doe"`.
- Переменной `isStudent` присваивается значение `true`.
- Переменной `temperature` присваивается значение `36.6`.

Инициализация переменной при объявлении является хорошей практикой, так как позволяет избежать использования переменных с неопределенными значениями и снижает риск возникновения ошибок.

##### **Особенности инициализации:**

1. **Явная инициализация:**
   - При инициализации переменной явно указывается значение, которое будет присвоено переменной при её создании.
   - **Пример:**
     ```csharp
     int count = 10;  // Явная инициализация
     ```

2. **Неявная типизация и инициализация с `var`:**
   - В C# существует возможность неявной типизации с помощью ключевого слова `var`. В этом случае тип переменной определяется компилятором на основе присваиваемого значения.
   - **Пример:**
     ```csharp
     var count = 10;  // Компилятор определяет, что count — это int
     var message = "Hello, world!";  // message — это string
     ```

   **Важно:**
   - `var` можно использовать только при одновременном объявлении и инициализации переменной. Если попытаться объявить переменную с `var` без присвоения значения, это приведет к ошибке компиляции.
   - Неявная типизация не означает, что переменная становится динамически типизированной — она по-прежнему имеет строгий тип, определенный компилятором на этапе компиляции.

3. **Инициализация ссылочных типов:**
   - Для ссылочных типов, таких как объекты классов, инициализация может включать создание нового экземпляра объекта с помощью ключевого слова `new`.
   - **Пример:**
     ```csharp
     string name = "Alice";
     DateTime currentDate = new DateTime(2024, 9, 3);  // Создание нового объекта DateTime
     ```

   В этом примере переменной `currentDate` присваивается новый объект типа `DateTime`, представляющий собой дату 3 сентября 2024 года.

4. **Поздняя инициализация:**
   - Переменные могут быть объявлены без начальной инициализации, а значение им может быть присвоено позже в коде.
   - **Пример:**
     ```csharp
     int age;
     age = 30;  // Поздняя инициализация
     ```

   Это может быть полезно в ситуациях, когда значение переменной зависит от условий, вычислений или данных, доступных только на более поздних этапах выполнения программы.

#### **2.3.3 Примеры кода**

Рассмотрим несколько примеров, демонстрирующих различные сценарии объявления и инициализации переменных в C#.

**Пример 1: Объявление и инициализация переменных при объявлении**
```csharp
int age = 25;
string name = "John Doe";
bool isStudent = true;
double temperature = 36.6;

Console.WriteLine($"Name: {name}, Age: {age}, Student: {isStudent}, Temperature: {temperature}");
```
**Описание:**
- В этом примере все переменные объявляются и инициализируются одновременно. Затем их значения выводятся на консоль.

**Пример 2: Объявление переменной с последующей инициализацией**
```csharp
int score;
score = 95;

Console.WriteLine($"Score: {score}");
```
**Описание:**
- Здесь переменная `score` сначала объявляется, а значение ей присваивается позже. Такой подход полезен, когда значение переменной определяется на основе вычислений или логики программы.

**Пример 3: Использование `var` для неявной типизации**
```csharp
var count = 10;  // int
var message = "Hello, world!";  // string

Console.WriteLine($"Count: {count}, Message: {message}");
```
**Описание:**
- В этом примере тип переменной определяется компилятором на основе присваиваемого значения. `count` будет интерпретирован как `int`, а `message` — как `string`.

**Пример 4: Инициализация объектов ссылочных типов**
```csharp
DateTime currentDate = new DateTime(2024, 9, 3);
string greeting = "Good morning!";
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

Console.WriteLine($"Date: {currentDate.ToShortDateString()}, Greeting: {greeting}");
Console.WriteLine("Numbers: " + string.Join(", ", numbers));
```
**Описание:**
- В этом примере создается новый объект `DateTime` с заданной датой, строка `greeting`, и объект типа `List<int>`, содержащий список целых чисел. 

**Пример 5: Использование Nullable типов**
```csharp
int? possibleNullInt = null;
Console.WriteLine($"Has value: {possibleNullInt.HasValue}");
possibleNullInt = 42;
Console.WriteLine($"Value: {possibleNullInt.Value}");
```
**Описание:**
- Здесь `possibleNullInt` — это Nullable тип (`int?`), который может принимать значение `null`. Сначала переменная инициализируется значением `null`, а затем ей присваивается целое число 42.

---

Эти примеры демонстрируют различные способы объявления и инициализации переменных в C#, подчеркивая гибкость языка и возможности работы с различными типами данных. Понимание этих механизмов является ключевым для написания надежного и эффективного кода.
### 2.4 Область видимости переменных

---

Область видимости переменной определяет, в каких частях программы переменная может быть доступна для использования. В C# область видимости варьируется в зависимости от того, где и как была объявлена переменная. Понимание концепции области видимости критически важно для эффективного управления состоянием программы и предотвращения ошибок, связанных с доступом к переменным.

#### **2.4.1 Локальные переменные: область действия внутри метода**

**Локальные переменные** — это переменные, объявленные внутри метода, конструктора или другого блока кода (например, в цикле или условной конструкции). Область видимости локальной переменной ограничивается блоком кода, в котором она объявлена.

**Основные характеристики локальных переменных:**
- Доступны только в пределах того блока, в котором они объявлены.
- Уничтожаются по завершении выполнения блока кода.
- Должны быть инициализированы перед использованием, иначе возникнет ошибка компиляции.

**Пример:**
```csharp
public void CalculateSum()
{
    int a = 5; // Локальная переменная
    int b = 10; // Локальная переменная
    int sum = a + b; // Локальная переменная

    Console.WriteLine($"Sum: {sum}");
}
// Переменные a, b и sum недоступны за пределами метода CalculateSum
```

В этом примере переменные `a`, `b` и `sum` являются локальными переменными метода `CalculateSum`. Они доступны только внутри этого метода и уничтожаются после завершения его выполнения.

**Пример с блоками кода:**
```csharp
public void ExampleMethod()
{
    if (true)
    {
        int x = 10;  // Локальная переменная в блоке if
        Console.WriteLine(x); // Доступно внутри блока if
    }
    // Console.WriteLine(x);  // Ошибка: x не существует за пределами блока if
}
```

Здесь переменная `x` доступна только внутри блока `if`. Попытка доступа к ней за пределами этого блока приведет к ошибке компиляции.

#### **2.4.2 Переменные класса (поля)**

**Переменные класса** (или поля) объявляются непосредственно в теле класса, но вне любых методов, конструкторов или других блоков кода. Область видимости таких переменных распространяется на весь класс, и они доступны во всех его методах и конструкторах.

**Основные характеристики полей:**
- Могут быть как приватными, так и публичными (или защищенными), что определяет доступ к ним из других классов или наследников.
- Существуют на протяжении всего времени существования объекта класса.
- Инициализируются значением по умолчанию (например, для числовых типов — 0, для логических — `false`, для ссылочных типов — `null`), если не было задано явное начальное значение.

**Пример:**
```csharp
public class Person
{
    private string name; // Приватное поле класса
    private int age; // Приватное поле класса

    public void SetDetails(string name, int age)
    {
        this.name = name; // Доступ к полю класса
        this.age = age; // Доступ к полю класса
    }

    public void DisplayDetails()
    {
        Console.WriteLine($"Name: {name}, Age: {age}");
    }
}
```

В этом примере поля `name` и `age` являются переменными класса. Они объявлены в теле класса `Person` и доступны во всех его методах. Эти поля приватные (`private`), что означает, что они недоступны за пределами класса `Person`.

**Пример с модификаторами доступа:**
```csharp
public class Car
{
    public string Make; // Публичное поле
    private string model; // Приватное поле

    public void DisplayMake()
    {
        Console.WriteLine($"Make: {Make}");
    }

    private void DisplayModel()
    {
        Console.WriteLine($"Model: {model}");
    }
}
```

Здесь поле `Make` является публичным и доступным из любого места, где доступен экземпляр класса `Car`. Поле `model` является приватным и доступно только внутри самого класса `Car`.

#### **2.4.3 Глобальные переменные: в C# отсутствуют, аналог в виде полей класса**

В C# нет прямой концепции **глобальных переменных**, которые были бы доступны из любого места программы. Однако аналогом глобальных переменных могут служить статические поля класса, которые доступны в пределах всей программы через сам класс, а не через экземпляры этого класса.

**Основные характеристики:**
- Статические поля объявляются с ключевым словом `static`.
- Такие поля существуют в единственном экземпляре на весь класс, а не на каждый объект.
- Доступ к статическим полям осуществляется через имя класса.

**Пример:**
```csharp
public class GlobalSettings
{
    public static string ApplicationName = "My Application";
    public static int MaxUsers = 100;
}

public class Program
{
    public static void Main()
    {
        Console.WriteLine(GlobalSettings.ApplicationName);
        Console.WriteLine(GlobalSettings.MaxUsers);
    }
}
```

В этом примере `ApplicationName` и `MaxUsers` — это статические поля класса `GlobalSettings`, которые могут рассматриваться как аналоги глобальных переменных. Они доступны из любого места программы, где виден класс `GlobalSettings`, и могут быть использованы без создания экземпляра этого класса.

#### **2.4.4 Ключевое слово `static` и его влияние на переменные**

Ключевое слово **`static`** используется в C# для определения статических членов класса, включая переменные (поля), методы и свойства. Статические члены принадлежат самому классу, а не конкретным его экземплярам.

**Основные характеристики `static`:**
- Статическая переменная существует в единственном экземпляре для всего класса и делится всеми объектами этого класса.
- Статические переменные и методы доступны без создания экземпляра класса.
- Статические члены класса не могут обращаться к нестатическим членам напрямую, так как последние зависят от конкретного экземпляра.

**Пример использования `static`:**
```csharp
public class Counter
{
    public static int Count = 0;  // Статическое поле

    public void Increment()
    {
        Count++;  // Инкремент статической переменной
    }
}

public class Program
{
    public static void Main()
    {
        Counter c1 = new Counter();
        Counter c2 = new Counter();

        c1.Increment();
        c2.Increment();

        Console.WriteLine(Counter.Count);  // Выводит 2, так как Count общий для всех экземпляров
    }
}
```

В этом примере `Count` — это статическое поле, которое инкрементируется каждым вызовом метода `Increment`. Так как поле статическое, оно доступно через имя класса `Counter`, и его значение сохраняется между вызовами метода `Increment` для разных экземпляров класса `Counter`.

**Статические методы и свойства:**
- Помимо переменных, ключевое слово `static` также используется для методов и свойств. Статические методы могут вызываться без создания экземпляра класса.
- **Пример:**
  ```csharp
  public class MathUtility
  {
      public static int Square(int number)
      {
          return number * number;
      }
  }

  public class Program
  {
      public static void Main()
      {
          int result = MathUtility.Square(5);  // Вызов статического метода без создания объекта
          Console.WriteLine(result);  // Выводит 25
      }
  }
  ```

  В этом примере метод `Square` является статическим, и его можно вызвать напрямую через имя класса `MathUtility`, не создавая объект этого класса.

**Ограничения статических членов:**
- Статические методы не могут обращаться к нестатическим полям и методам класса, так как нестатические члены относятся к конкретным экземплярам, а статические — к самому классу.
- Статические поля и методы не поддерживают интерфейсы и наследование, так как они не могут быть переопределены в производных классах.

Таким образом, понятие области видимости переменных в C# охватывает локальные переменные, поля класса и статические переменные, каждая из которых имеет свои особенности и область применения. Правильное понимание и использование области видимости переменных способствует созданию более структурированного, читаемого и надежного кода.
### 2.5 Константы

---

Константы в C# играют важную роль в программировании, предоставляя способ объявить значения, которые не должны изменяться в течение выполнения программы. Они повышают читаемость и надежность кода, позволяя разработчикам обозначать важные значения, которые должны оставаться неизменными.

#### **2.5.1 Объявление и использование констант (`const`)**

Константы в C# объявляются с использованием ключевого слова `const`. Константа — это именованное значение, которое присваивается на этапе компиляции и не может быть изменено в ходе выполнения программы. Константы позволяют программам работать с неизменяемыми данными, такими как математические константы, физические величины или значения конфигурации.

**Объявление константы:**
```csharp
const тип_данных имя_константы = значение;
```

Где:
- **тип_данных** — это тип данных константы (например, `int`, `double`, `string` и т.д.).
- **имя_константы** — это имя константы, которое следует именовать с использованием соглашений о написании в верхнем регистре (например, `PI`, `MAX_VALUE`), чтобы выделить их среди переменных.
- **значение** — это значение, которое будет присвоено константе и не изменится в дальнейшем.

**Пример:**
```csharp
public class MathConstants
{
    public const double PI = 3.14159;
    public const int DAYS_IN_WEEK = 7;
    public const string DEFAULT_GREETING = "Hello, world!";
}
```

В этом примере:
- `PI` — это константа типа `double`, представляющая число π.
- `DAYS_IN_WEEK` — это константа типа `int`, представляющая количество дней в неделе.
- `DEFAULT_GREETING` — это константа типа `string`, представляющая строку приветствия.

**Особенности констант:**
- Константы не могут быть изменены после их инициализации.
- Константы могут использоваться во всех местах, где требуется неизменяемое значение, и обеспечивают возможность выполнения компиляционных проверок.
- Константы всегда должны быть инициализированы при объявлении, так как они вычисляются на этапе компиляции.

**Пример использования констант:**
```csharp
public class Circle
{
    public const double PI = 3.14159;

    public double CalculateCircumference(double radius)
    {
        return 2 * PI * radius;  // Использование константы для расчета длины окружности
    }
}

public class Program
{
    public static void Main()
    {
        Circle circle = new Circle();
        double circumference = circle.CalculateCircumference(5);
        Console.WriteLine($"Circumference: {circumference}");
    }
}
```

В этом примере константа `PI` используется для расчета длины окружности по заданному радиусу. Значение `PI` остается неизменным на протяжении всего выполнения программы.

#### **2.5.2 Разница между константами и переменными**

Константы и переменные служат для хранения данных, но между ними есть важные различия:

1. **Изменяемость:**
   - **Переменные** могут изменять своё значение в ходе выполнения программы.
   - **Константы** не могут быть изменены после их объявления и инициализации.

2. **Инициализация:**
   - **Переменные** могут быть объявлены без инициализации и инициализированы позднее, а могут изменяться несколько раз в процессе работы программы.
   - **Константы** должны быть инициализированы сразу при объявлении, и их значение не может быть изменено впоследствии.

3. **Область памяти:**
   - **Переменные** хранятся в памяти, а их значение может изменяться. Для ссылочных типов переменные содержат указатель на объект в управляемой куче.
   - **Константы** не хранятся в обычной памяти. Вместо этого их значения встраиваются в код в точках использования. Это делает их использование быстрым, но также приводит к тому, что изменение значения константы требует перекомпиляции всего кода, который на нее ссылается.

**Пример различий:**
```csharp
public class Example
{
    public const int MaxValue = 100;  // Константа
    public int currentValue = 0;  // Переменная

    public void IncrementValue()
    {
        if (currentValue < MaxValue)
        {
            currentValue++;  // Переменная может изменяться
        }
    }
}
```

Здесь `MaxValue` — это константа, которая никогда не изменяется, тогда как `currentValue` — это переменная, значение которой можно изменять.

#### **2.5.3 Использование `readonly` для неизменяемых полей**

В C# помимо констант существует ключевое слово **`readonly`**, которое используется для объявления неизменяемых полей. Поля, помеченные как `readonly`, могут быть инициализированы только один раз — либо в момент их объявления, либо в конструкторе класса. В отличие от `const`, `readonly` поля могут принимать значения, которые определяются на этапе выполнения, а не компиляции.

**Объявление `readonly` поля:**
```csharp
readonly тип_данных имя_поля;
```

**Пример использования `readonly`:**
```csharp
public class Configuration
{
    public readonly string FilePath;
    public readonly DateTime CreatedAt;

    public Configuration(string filePath)
    {
        FilePath = filePath;  // Инициализация в конструкторе
        CreatedAt = DateTime.Now;  // Значение определяется в момент выполнения
    }
}
```

**Особенности `readonly` полей:**
- Поля `readonly` могут быть инициализированы только один раз — в момент их создания или в конструкторе.
- В отличие от `const`, `readonly` поля могут принимать разные значения в зависимости от конструктора или логики выполнения программы.
- `readonly` поля, как и переменные, хранятся в памяти, и их значения могут быть разными для каждого экземпляра класса.

**Пример с `readonly`:**
```csharp
public class Rectangle
{
    public readonly int Width;
    public readonly int Height;

    public Rectangle(int width, int height)
    {
        Width = width;
        Height = height;
    }

    public int CalculateArea()
    {
        return Width * Height;
    }
}

public class Program
{
    public static void Main()
    {
        Rectangle rect = new Rectangle(10, 20);
        Console.WriteLine($"Area: {rect.CalculateArea()}");  // Выводит 200
    }
}
```

В этом примере `Width` и `Height` — это `readonly` поля. Их значения устанавливаются при создании объекта класса `Rectangle` и не могут быть изменены впоследствии. Это делает объект прямоугольника неизменяемым с точки зрения его размеров.

**Основные различия между `readonly` и `const`:**
- **`const`:** Значение должно быть определено во время компиляции и не может быть изменено. Константы являются статическими по своей природе, и их значение одинаково для всех экземпляров класса.
- **`readonly`:** Значение может быть установлено во время выполнения программы (например, в конструкторе) и может быть разным для разных экземпляров класса. Поля `readonly` не являются статическими по умолчанию, хотя могут быть объявлены как статические с помощью ключевого слова `static`.

**Пример сравнения:**
```csharp
public class Example
{
    public const int MaxSize = 100;  // Должно быть известно на этапе компиляции
    public readonly int MaxLimit;  // Может быть установлено в конструкторе

    public Example(int maxLimit)
    {
        MaxLimit = maxLimit;  // Значение задается на этапе выполнения
    }
}
```

В этом примере `MaxSize` — это `const`, и его значение должно быть известно на этапе компиляции. `MaxLimit` — это `readonly` поле, и его значение может быть установлено в конструкторе при создании объекта, что дает больше гибкости.

Таким образом, использование `const` и `readonly` полей в C# позволяет разработчикам создавать неизменяемые значения с разной степенью гибкости, обеспечивая как оптимизацию на уровне компиляции (`const`), так и возможность задания значений во время выполнения (`readonly`). Это делает код более предсказуемым и безопасным, предотвращая случайные изменения критических данных.

---

## 3. Выражения в C#
---

### 3.1 Определение выражений

---

В программировании выражения являются фундаментальной концепцией, играющей ключевую роль в процессе выполнения вычислений, принятия решений и обработки данных. В C# выражения используются повсеместно — от выполнения простейших арифметических операций до сложных логических проверок и работы со строками. 

#### **3.1.1 Что такое выражение: комбинация операндов и операторов**

**Выражение** в C# — это комбинация операндов и операторов, которая вычисляется и возвращает некоторое значение. Операнды — это объекты или примитивные данные (например, числа, строки, переменные), над которыми выполняются операции. Операторы — это специальные символы или ключевые слова, которые указывают, какие действия необходимо выполнить над операндами.

**Основные элементы выражения:**
- **Операнды:** Переменные, константы, литералы, результаты выполнения функций и методы.
- **Операторы:** Символы или ключевые слова, задающие операцию. В C# есть арифметические, логические, побитовые, условные операторы и операторы присваивания.

**Пример простого выражения:**
```csharp
int result = 3 + 5;
```
В этом примере:
- Операнды: `3` и `5` — это целые числа.
- Оператор: `+` — это арифметический оператор сложения.
- Выражение `3 + 5` вычисляется и возвращает значение `8`, которое затем присваивается переменной `result`.

Выражения могут быть простыми (содержащими два операнда и один оператор) или сложными, состоящими из нескольких операций и вложенных выражений.

**Пример сложного выражения:**
```csharp
int x = 10;
int y = 5;
int z = (x + y) * 2 - (y - x);
```
В этом выражении:
- `(x + y)` — это подвыражение, которое сначала вычисляется.
- `(y - x)` — другое подвыражение.
- Затем выполняются операции умножения и вычитания.
- Все выражение вычисляется слева направо, с учетом приоритета операторов.

Выражения являются центральным элементом любых программ и используются в условных конструкциях (`if`, `switch`), циклах (`for`, `while`), методах и конструкторах, а также при обработке данных.

#### **3.1.2 Виды выражений: арифметические, логические, строковые и др.**

В C# существует несколько основных типов выражений, каждый из которых выполняет определенные функции в зависимости от контекста применения.

##### **1. Арифметические выражения**

**Арифметические выражения** выполняют математические операции над числовыми операндами. Эти выражения возвращают числовое значение в результате выполнения операций.

**Основные арифметические операторы:**
- **`+`** (сложение): Суммирует два операнда.
- **`-`** (вычитание): Вычитает один операнд из другого.
- **`*`** (умножение): Умножает два операнда.
- **`/`** (деление): Делит один операнд на другой.
- **`%`** (остаток от деления): Возвращает остаток от деления одного операнда на другой.

**Пример арифметического выражения:**
```csharp
int a = 10;
int b = 3;
int sum = a + b;  // 13
int product = a * b;  // 30
int quotient = a / b;  // 3
int remainder = a % b;  // 1
```

В этом примере переменные `sum`, `product`, `quotient` и `remainder` получают значения в результате выполнения соответствующих арифметических операций.

##### **2. Логические выражения**

**Логические выражения** используются для выполнения операций сравнения и булевых операций. Эти выражения возвращают логическое значение (`true` или `false`).

**Основные логические операторы:**
- **`&&`** (логическое И): Возвращает `true`, если оба операнда истинны.
- **`||`** (логическое ИЛИ): Возвращает `true`, если хотя бы один операнд истинен.
- **`!`** (логическое НЕ): Инвертирует логическое значение операнда.

**Операторы сравнения:**
- **`==`** (равенство): Возвращает `true`, если операнды равны.
- **`!=`** (неравенство): Возвращает `true`, если операнды не равны.
- **`>`** (больше): Возвращает `true`, если левый операнд больше правого.
- **`<`** (меньше): Возвращает `true`, если левый операнд меньше правого.
- **`>=`** (больше или равно): Возвращает `true`, если левый операнд больше или равен правому.
- **`<=`** (меньше или равно): Возвращает `true`, если левый операнд меньше или равен правому.

**Пример логического выражения:**
```csharp
int x = 5;
int y = 10;
bool isEqual = (x == y);  // false
bool isGreater = (x > y);  // false
bool isEitherTrue = (x == 5 || y == 5);  // true
bool isNotEqual = !(x == y);  // true
```

Здесь переменные `isEqual`, `isGreater`, `isEitherTrue` и `isNotEqual` принимают значения в зависимости от выполнения логических операций.

##### **3. Строковые выражения**

**Строковые выражения** применяются для работы со строками. Они включают в себя операции конкатенации (объединения строк) и другие манипуляции со строками.

**Основные строковые операторы и методы:**
- **`+`** (конкатенация): Объединяет две строки в одну.
- **`string.Concat`**: Объединяет несколько строк.
- **`string.Substring`**: Возвращает подстроку из строки.
- **`string.ToUpper`/`string.ToLower`**: Преобразует строку в верхний или нижний регистр.
- **`string.Replace`**: Заменяет вхождения одной подстроки другой.

**Пример строкового выражения:**
```csharp
string firstName = "John";
string lastName = "Doe";
string fullName = firstName + " " + lastName;  // "John Doe"
string greeting = "Hello, " + fullName + "!";  // "Hello, John Doe!"
```

В этом примере строки `firstName` и `lastName` объединяются с помощью оператора `+` для создания полной строки `fullName`, которая затем используется в строке приветствия `greeting`.

##### **4. Выражения присваивания**

**Выражения присваивания** используются для присвоения значений переменным. Такие выражения обычно включают оператор присваивания `=`.

**Основные операторы присваивания:**
- **`=`**: Присваивает правый операнд левому операнду.
- **`+=`**: Сложение с присваиванием — прибавляет правый операнд к левому и присваивает результат.
- **`-=`**: Вычитание с присваиванием — вычитает правый операнд из левого и присваивает результат.
- **`*=`**: Умножение с присваиванием — умножает левый операнд на правый и присваивает результат.
- **`/=`**: Деление с присваиванием — делит левый операнд на правый и присваивает результат.
- **`%=`**: Остаток с присваиванием — вычисляет остаток от деления и присваивает результат.

**Пример выражений присваивания:**
```csharp
int x = 5;
x += 10;  // x теперь равно 15
x *= 2;  // x теперь равно 30
x /= 3;  // x теперь равно 10
x -= 5;  // x теперь равно 5
```

В этом примере переменная `x` изменяет своё значение в зависимости от выполняемых операций присваивания.

##### **5. Условные выражения**

**Условные выражения** позволяют выполнять одну из двух операций в зависимости от логического условия. Основной оператор для создания условных выражений — тернарный оператор `? :`.

**Пример условного выражения:**
```csharp
int a = 10;
int b = 20;
int max = (a > b) ? a : b;  // Если a > b, max = a, иначе max = b
```

Здесь тернарный оператор используется для присвоения переменной `max` значения `a` или `b` в зависимости от того, какое из них больше.

##### **6. Побитовые выражения**

**Побитовые выражения** используются для выполнения операций на уровне отдельных битов целочисленных операндов. Эти выражения применяются в задачах, требующих низкоуровневой обработки данных, таких как работа с флагами, масками, а также оптимизация производительности в некоторых алгоритмах.

**Основные побитовые операторы:**
- **`&`** (побитовое И): Выполняет побитовое И для каждого соответствующего бита двух операндов. Результирующий бит равен `1`, только если оба исходных бита равны `1`.
- **`|`** (побитовое ИЛИ): Выполняет побитовое ИЛИ для каждого соответствующего бита двух операндов. Результирующий бит равен `1`, если хотя бы один из исходных битов равен `1`.
- **`^`** (побитовое исключающее ИЛИ): Выполняет побитовое исключающее ИЛИ (XOR) для каждого соответствующего бита двух операндов. Результирующий бит равен `1`, только если один из исходных битов равен `1`, а другой — `0`.
- **`~`** (побитовое НЕ): Инвертирует каждый бит операнда (меняет `0` на `1` и `1` на `0`).
- **`<<`** (сдвиг влево): Сдвигает биты операнда влево на заданное количество позиций. Освободившиеся младшие биты заполняются нулями.
- **`>>`** (сдвиг вправо): Сдвигает биты операнда вправо на заданное количество позиций. Для целых чисел со знаком старшие биты заполняются знакомым битом (`0` или `1`), для беззнаковых чисел — нулями.

**Пример побитовых выражений:**
```csharp
int a = 5;  // В двоичном представлении: 0101
int b = 3;  // В двоичном представлении: 0011

int resultAnd = a & b;  // Побитовое И: 0101 & 0011 = 0001 (1 в десятичной системе)
int resultOr = a | b;   // Побитовое ИЛИ: 0101 | 0011 = 0111 (7 в десятичной системе)
int resultXor = a ^ b;  // Побитовое исключающее ИЛИ: 0101 ^ 0011 = 0110 (6 в десятичной системе)
int resultNot = ~a;     // Побитовое НЕ: ~0101 = 1010 (в десятичной системе: -6)
int resultShiftLeft = a << 1;  // Сдвиг влево: 0101 << 1 = 1010 (10 в десятичной системе)
int resultShiftRight = a >> 1; // Сдвиг вправо: 0101 >> 1 = 0010 (2 в десятичной системе)
```

В этом примере выполняются различные побитовые операции, которые манипулируют отдельными битами чисел `a` и `b`, а результат сохраняется в соответствующих переменных.

##### **7. Типовые (кастинговые) выражения**

**Типовые выражения** используются для преобразования значения одного типа в другой. C# поддерживает как явное, так и неявное приведение типов.

**Основные операции приведения типов:**
- **Неявное приведение**: Приведение, которое выполняется автоматически компилятором, когда типы совместимы и преобразование безопасно.
- **Явное приведение**: Приведение, которое требует указания типа, к которому нужно преобразовать значение. Применяется в случаях, когда существует риск потери данных или не все значения исходного типа могут быть представлены целевым типом.

**Пример типовых выражений:**
```csharp
int x = 10;
double y = x;  // Неявное приведение от int к double

double a = 9.8;
int b = (int)a;  // Явное приведение от double к int (дробная часть будет отброшена)
```

Здесь первое выражение демонстрирует неявное приведение `int` к `double`, тогда как второе выражение требует явного приведения с потерей данных при отбрасывании дробной части.

##### **8. Индексационные выражения**

**Индексационные выражения** используются для доступа к элементам массивов, списков и других коллекций по их индексу.

**Пример индексационного выражения:**
```csharp
int[] numbers = { 10, 20, 30, 40 };
int firstNumber = numbers[0];  // Доступ к первому элементу массива
numbers[2] = 35;  // Изменение третьего элемента массива
```

В этом примере выражения `numbers[0]` и `numbers[2]` позволяют получить доступ к элементам массива и модифицировать их значения.

##### **9. Лямбда-выражения**

**Лямбда-выражения** используются для определения анонимных функций, которые могут содержать выражения и инструкции. Эти выражения особенно полезны при работе с LINQ (Language Integrated Query) и другими функциональными подходами в C#.

**Пример лямбда-выражения:**
```csharp
Func<int, int, int> sum = (x, y) => x + y;
int result = sum(5, 3);  // Результат: 8
```

Здесь лямбда-выражение `(x, y) => x + y` определяет анонимную функцию, которая принимает два параметра `x` и `y` и возвращает их сумму. Это выражение затем используется для вычисления суммы двух чисел.

---

Выражения в C# предоставляют мощный и гибкий инструмент для выполнения разнообразных вычислений, принятия решений и обработки данных. Каждое из видов выражений — от арифметических до лямбда-выражений — выполняет свою роль в различных контекстах программирования. Понимание и умение правильно использовать эти выражения позволяет создавать эффективные и поддерживаемые программы.

---

#### **Оператор инкремента и декремента**

Операторы инкремента (`++`) и декремента (`--`) в C# используются для увеличения или уменьшения значения переменной на единицу соответственно. Эти операторы могут использоваться как в префиксной, так и в постфиксной формах, каждая из которых имеет свои особенности и влияет на порядок вычислений в выражениях.

---

##### **`++` и `--`, их префиксные и постфиксные формы**

###### **1. Оператор инкремента (`++`)**

**Оператор инкремента** увеличивает значение переменной на единицу. В зависимости от позиции оператора относительно переменной, оператор инкремента может быть представлен в двух формах: **префиксной** и **постфиксной**.

- **Префиксная форма (`++x`):** Оператор инкремента находится перед переменной. В этом случае сначала происходит увеличение значения переменной на единицу, а затем новое значение используется в выражении.
  
- **Постфиксная форма (`x++`):** Оператор инкремента находится после переменной. В этом случае сначала используется текущее значение переменной в выражении, а затем значение переменной увеличивается на единицу.

**Примеры использования:**
```csharp
int x = 5;

// Префиксный инкремент
int y = ++x;
// x равно 6, y равно 6

// Постфиксный инкремент
int z = x++;
// z равно 6, x равно 7
```

В этом примере:
- В строке `int y = ++x;` префиксный инкремент сначала увеличивает `x` до 6, а затем присваивает это значение переменной `y`.
- В строке `int z = x++;` постфиксный инкремент сначала присваивает текущее значение `x` (6) переменной `z`, а затем увеличивает `x` на единицу (до 7).

###### **2. Оператор декремента (`--`)**

**Оператор декремента** уменьшает значение переменной на единицу. Подобно оператору инкремента, оператор декремента может использоваться в префиксной и постфиксной формах.

- **Префиксная форма (`--x`):** Оператор декремента находится перед переменной. В этом случае сначала происходит уменьшение значения переменной на единицу, а затем новое значение используется в выражении.
  
- **Постфиксная форма (`x--`):** Оператор декремента находится после переменной. В этом случае сначала используется текущее значение переменной в выражении, а затем значение переменной уменьшается на единицу.

**Примеры использования:**
```csharp
int a = 10;

// Префиксный декремент
int b = --a;
// a равно 9, b равно 9

// Постфиксный декремент
int c = a--;
// c равно 9, a равно 8
```

В этом примере:
- В строке `int b = --a;` префиксный декремент сначала уменьшает `a` до 9, а затем присваивает это значение переменной `b`.
- В строке `int c = a--;` постфиксный декремент сначала присваивает текущее значение `a` (9) переменной `c`, а затем уменьшает `a` на единицу (до 8).

---

##### **Отличия и примеры использования**

Разница между префиксной и постфиксной формами операторов инкремента и декремента заключается в порядке выполнения операций и в том, какое значение будет использоваться в выражении.

- **Префиксная форма (`++x`, `--x`)**: Значение переменной изменяется (увеличивается или уменьшается) перед тем, как оно будет использовано в выражении.
- **Постфиксная форма (`x++`, `x--`)**: Текущее значение переменной сначала используется в выражении, а затем изменяется.

**Примеры с различием в использовании префиксной и постфиксной форм:**

1. **Пример с оператором инкремента в цикле:**
```csharp
for (int i = 0; i < 5; ++i)
{
    Console.WriteLine(i);
}
```
В этом примере префиксный инкремент (`++i`) используется в цикле `for`. Так как инкремент происходит до использования значения `i` в теле цикла, это не влияет на результат, и цикл отработает как обычно, выводя числа от 0 до 4.

2. **Пример с оператором инкремента в сложных выражениях:**
```csharp
int m = 5;
int n = 10;
int result = m++ + ++n;
// m равно 6, n равно 11, result равно 16
```
Здесь происходит сложное вычисление, включающее как постфиксный, так и префиксный инкремент:
- `m++` использует текущее значение `m` (5) перед его увеличением до 6.
- `++n` сначала увеличивает `n` до 11, а затем использует это значение.
- В результате `result` получает значение 16.

3. **Пример с оператором декремента в условии:**
```csharp
int p = 3;
int q = --p + p--; 
// p равно 1, q равно 4
```
Здесь префиксный и постфиксный декременты используются совместно в одном выражении:
- `--p` уменьшает `p` до 2, а затем это значение используется в выражении.
- После этого `p--` использует значение 2, а затем уменьшает `p` до 1.
- В итоге `q` получает значение 4 (2 + 2).

**Вывод:**
- Префиксная форма операторов используется там, где необходимо сразу получить измененное значение.
- Постфиксная форма удобна в ситуациях, когда необходимо сначала использовать текущее значение переменной, а затем его изменить.

**Рекомендации:**
- Используйте префиксные операторы инкремента и декремента, когда важно сразу получить новое значение переменной.
- Применяйте постфиксные операторы, если текущее значение переменной должно быть использовано перед его изменением.
- Будьте особенно внимательны при использовании этих операторов в сложных выражениях, так как это может привести к путанице и ошибкам в коде. Лучше избегать чрезмерного усложнения выражений, чтобы код оставался читаемым и понятным.
### 3.2 Тернарный оператор

---

**Тернарный оператор** в C# является сокращенной формой условного выражения и предоставляет удобный способ написания простых логических проверок и присваивания значений. Он позволяет в одной строке кода выразить выбор между двумя значениями в зависимости от истинности или ложности условия.

---

#### **Синтаксис и применение (`? :`)**

Тернарный оператор в C# имеет следующий синтаксис:

```csharp
условие ? выражение1 : выражение2;
```

Где:
- **условие** — логическое выражение, которое возвращает значение типа `bool` (`true` или `false`).
- **выражение1** — выражение, которое выполняется и возвращается в случае, если `условие` истинно (`true`).
- **выражение2** — выражение, которое выполняется и возвращается в случае, если `условие` ложно (`false`).

**Принцип работы:**
- Если `условие` истинно (`true`), оператор возвращает результат вычисления `выражение1`.
- Если `условие` ложно (`false`), оператор возвращает результат вычисления `выражение2`.

Тернарный оператор часто используется для компактного присваивания значений переменным в зависимости от условия, а также для упрощения логических проверок в коде, где стандартное использование оператора `if-else` может быть избыточным.

#### **Примеры кода**

Рассмотрим несколько примеров использования тернарного оператора для решения различных задач.

1. **Простой пример с числами:**
   ```csharp
   int a = 5;
   int b = 10;
   int max = (a > b) ? a : b;
   Console.WriteLine($"Maximum: {max}");
   ```

   **Описание:**
   - В этом примере тернарный оператор используется для определения максимального значения между двумя числами `a` и `b`.
   - Если `a` больше `b`, переменной `max` присваивается значение `a`, иначе — значение `b`.
   - В результате на консоль выводится максимальное из двух значений, в данном случае — 10.

2. **Пример с проверкой четности числа:**
   ```csharp
   int number = 7;
   string result = (number % 2 == 0) ? "Even" : "Odd";
   Console.WriteLine($"The number is {result}.");
   ```

   **Описание:**
   - Здесь тернарный оператор используется для проверки, является ли число `number` четным или нечетным.
   - Если остаток от деления числа на 2 равен 0 (`number % 2 == 0`), то переменной `result` присваивается строка `"Even"`, иначе — строка `"Odd"`.
   - В результате на консоль выводится сообщение о том, является ли число четным или нечетным, в данном случае — "The number is Odd."

3. **Пример с использованием тернарного оператора для присваивания значения по умолчанию:**
   ```csharp
   string userInput = null;
   string message = (userInput != null) ? userInput : "No input provided";
   Console.WriteLine(message);
   ```

   **Описание:**
   - В этом примере тернарный оператор используется для проверки, является ли переменная `userInput` `null`.
   - Если `userInput` не равен `null`, переменной `message` присваивается значение `userInput`. В противном случае присваивается строка `"No input provided"`.
   - На консоль выводится сообщение, в котором отображается введенное пользователем значение, либо сообщение о том, что ввод не был предоставлен. В данном случае выводится `"No input provided"`.

4. **Пример с вложенными тернарными операторами:**
   ```csharp
   int score = 85;
   string grade = (score >= 90) ? "A" :
                  (score >= 80) ? "B" :
                  (score >= 70) ? "C" :
                  (score >= 60) ? "D" : "F";
   Console.WriteLine($"Grade: {grade}");
   ```

   **Описание:**
   - В этом примере тернарный оператор используется для присваивания переменной `grade` оценки в зависимости от значения переменной `score`.
   - Если `score` больше или равен 90, переменная `grade` получает значение `"A"`. Если `score` больше или равен 80, но меньше 90, `grade` получает значение `"B"` и так далее.
   - В результате на консоль выводится оценка, соответствующая значению `score`, в данном случае — "Grade: B".

5. **Пример с использованием тернарного оператора для выбора между методами:**
   ```csharp
   bool isActive = true;
   string message = isActive ? GetActiveMessage() : GetInactiveMessage();
   Console.WriteLine(message);

   string GetActiveMessage()
   {
       return "The system is active.";
   }

   string GetInactiveMessage()
   {
       return "The system is inactive.";
   }
   ```

   **Описание:**
   - Здесь тернарный оператор используется для выбора между двумя методами в зависимости от состояния переменной `isActive`.
   - Если `isActive` равно `true`, вызывается метод `GetActiveMessage()`, который возвращает сообщение `"The system is active."`. В противном случае вызывается метод `GetInactiveMessage()`.
   - На консоль выводится соответствующее сообщение в зависимости от состояния системы, в данном случае — "The system is active."

6. **Пример с проверкой значения и его модификацией:**
   ```csharp
   int temperature = 25;
   string weather = (temperature > 30) ? "Hot" :
                    (temperature < 10) ? "Cold" : "Moderate";
   Console.WriteLine($"The weather is {weather}.");
   ```

   **Описание:**
   - В этом примере тернарный оператор используется для определения типа погоды в зависимости от значения переменной `temperature`.
   - Если температура выше 30 градусов, переменной `weather` присваивается строка `"Hot"`, если ниже 10 градусов — `"Cold"`, иначе — `"Moderate"`.
   - На консоль выводится сообщение о погоде в зависимости от значения переменной `temperature`, в данном случае — "The weather is Moderate."

---

Тернарный оператор является мощным инструментом в C# для упрощения и сокращения кода, где требуется выполнить простую проверку и вернуть одно из двух значений. Его использование помогает сделать код более компактным и понятным, особенно в случаях, когда условное выражение достаточно простое. Однако при использовании тернарного оператора следует соблюдать осторожность, чтобы не усложнять код избыточными вложенными операциями, что может негативно сказаться на читаемости и поддерживаемости программы.

### 3.3 Приоритет операторов и ассоциативность

---

В языке программирования C# операторы имеют различный приоритет и ассоциативность, которые определяют порядок выполнения операций в выражениях. Понимание этих понятий является ключом к написанию корректного и предсказуемого кода.

#### **3.3.1 Таблица приоритетов операторов**

Приоритет операторов определяет, в каком порядке выполняются операции в выражении, когда они следуют друг за другом. Операторы с более высоким приоритетом выполняются раньше операторов с более низким приоритетом.

**Таблица приоритетов операторов в C#:**

| Приоритет | Операторы                               | Описание                               |
| --------- | --------------------------------------- | -------------------------------------- |
| 1         | `()`                                    | Скобки (группировка)                   |
| 2         | `++`, `--`                              | Префиксные инкремент и декремент       |
| 3         | `+`, `-`                                | Унарные плюс и минус                   |
| 4         | `!`, `~`                                | Логическое НЕ, побитовое НЕ            |
| 5         | `*`, `/`, `%`                           | Умножение, деление, остаток от деления |
| 6         | `+`, `-`                                | Сложение, вычитание                    |
| 7         | `<<`, `>>`                              | Сдвиги (влево, вправо)                 |
| 8         | `<`, `<=`, `>`, `>=`                    | Операции сравнения                     |
| 9         | `==`, `!=`                              | Равенство и неравенство                |
| 10        | `&`                                     | Побитовое И                            |
| 11        | `^`                                     | Побитовое исключающее ИЛИ              |
| 12        | `\| `                                   | Побитовое ИЛИ                          |
| 13        | `&&`                                    | Логическое И                           |
| 14        | `\|\|`                                  | Логическое ИЛИ                         |
| 15        | `?:`                                    | Тернарный условный оператор            |
| 16        | `=`, `+=`, `-=`, `*=`, `/=`, `%=` и др. | Операторы присваивания                 |
| 17        | `,`                                     | Оператор запятая                       |

Эта таблица показывает приоритеты операторов от самого высокого (1) до самого низкого (17). Операции с операторами более высокого приоритета выполняются раньше, чем с операторами более низкого приоритета.

#### **3.3.2 Порядок выполнения операций**

Порядок выполнения операций определяется приоритетом операторов, а также ассоциативностью (которую мы обсудим далее). Если в выражении присутствуют операторы с разным приоритетом, операции выполняются в порядке убывания приоритета.

**Пример:**
```csharp
int result = 10 + 5 * 2;
```

Здесь оператор умножения (`*`) имеет более высокий приоритет, чем оператор сложения (`+`), поэтому сначала выполняется умножение (`5 * 2 = 10`), и только затем результат умножения складывается с 10 (`10 + 10 = 20`). Окончательное значение `result` будет равно 20.

Когда в выражении встречаются операторы с одинаковым приоритетом, порядок выполнения операций определяется ассоциативностью.

#### **3.3.3 Ассоциативность операторов: слева направо и справа налево**

Ассоциативность определяет, как будут выполняться операции с операторами одинакового приоритета, если они идут подряд в выражении. В C# операторы могут иметь левую (слева направо) или правую (справа налево) ассоциативность.

- **Левая ассоциативность (слева направо):**
  - Операции выполняются последовательно слева направо.
  - Примеры операторов: арифметические (`+`, `-`, `*`, `/`), побитовые (`&`, `|`, `^`), логические (`&&`, `||`).

- **Правая ассоциативность (справа налево):**
  - Операции выполняются последовательно справа налево.
  - Примеры операторов: присваивание (`=`, `+=`, `-=`), тернарный оператор (`?:`).

**Пример левой ассоциативности:**
```csharp
int result = 10 - 5 - 2;
```

Здесь оба оператора вычитания (`-`) имеют одинаковый приоритет и левую ассоциативность, поэтому операции выполняются слева направо:
- Сначала выполняется `10 - 5`, что дает `5`.
- Затем результат (`5`) используется в следующем вычитании: `5 - 2`, что дает итоговый результат `3`.

**Пример правой ассоциативности:**
```csharp
int a = 5;
int b = 10;
int c = 15;
a = b = c;
```

В этом примере операторы присваивания (`=`) имеют правую ассоциативность, поэтому операции выполняются справа налево:
- Сначала `b = c`, то есть `b` присваивается значение `15`.
- Затем `a = b`, и `a` также присваивается значение `15`.

В результате все три переменные (`a`, `b` и `c`) будут равны 15.

#### **3.3.4 Примеры выражений с разными операторами**

Рассмотрим несколько примеров выражений с операторами разного приоритета и ассоциативности для лучшего понимания.

1. **Пример с арифметическими операциями:**
   ```csharp
   int x = 2 + 3 * 4 - 5 / 5;
   ```
   **Порядок выполнения:**
   - Умножение (`3 * 4 = 12`) — выполняется первым.
   - Деление (`5 / 5 = 1`) — выполняется следующим.
   - Затем выполняется сложение (`2 + 12 = 14`).
   - Наконец, выполняется вычитание (`14 - 1 = 13`).
   - Итоговый результат: `x = 13`.

2. **Пример с операторами сравнения и логическими операторами:**
   ```csharp
   bool result = 5 > 3 && 10 <= 10 || 7 == 8;
   ```
   **Порядок выполнения:**
   - Сначала выполняются операции сравнения:
     - `5 > 3` — истинно (`true`).
     - `10 <= 10` — истинно (`true`).
     - `7 == 8` — ложно (`false`).
   - Затем выполняются логические операции, начиная с логического И (`&&`), так как оно имеет более высокий приоритет, чем логическое ИЛИ (`||`):
     - `true && true` — дает `true`.
   - Далее выполняется логическое ИЛИ:
     - `true || false` — дает `true`.
   - Итоговый результат: `result = true`.

3. **Пример с тернарным оператором:**
   ```csharp
   int score = 85;
   string grade = (score >= 90) ? "A" :
                  (score >= 80) ? "B" : "C";
   ```
   **Порядок выполнения:**
   - Оператор `?:` имеет правую ассоциативность, поэтому сначала проверяется условие `score >= 90`. Если оно истинно, присваивается значение `"A"`, если ложно — проверяется следующее условие `score >= 80`.
   - В данном случае `score = 85`, что больше 80, поэтому переменной `grade` присваивается значение `"B"`.

4. **Пример с комбинированными операциями:**
   ```csharp
   int a = 10;
   int b = 3;
   int result = a * b + b % a / b - a;
   ```
   **Порядок выполнения:**
   - Сначала выполняется умножение (`a * b = 30`).
   - Затем выполняется остаток от деления (`b % a = 3`).
   - Деление выполняется следующим (`3 / b = 1`).
   - Затем сложение (`30 + 1 = 31`).
   - Наконец, вычитание (`31 - a = 21`).
   - Итоговый результат: `result = 21`.

5. **Пример с присваиванием и сложением:**
   ```csharp
   int x = 5;
   int y = 10;
   int z = (x += y) + (x -= 2);
   ```
   **Порядок выполнения:**
   - Оператор присваивания (`+=`, `-=`) имеет правую ассоциативность, и выполняется следующим образом:
     - Сначала `x += y` (то есть `x = x + y)

```csharp
x += y; // x = 5 + 10 = 15
```

- После выполнения операции `x += y`, значение переменной `x` становится равно `15`.
  
```csharp
x -= 2; // x = 15 - 2 = 13
```

- Затем выполняется операция `x -= 2`, после чего значение `x` уменьшается до `13`.

Теперь, когда обе операции присваивания выполнены, они используются в выражении:

```csharp
int z = (x += y) + (x -= 2);
```

- Значение `z` вычисляется как сумма результатов двух подвыражений:
  - Первое подвыражение `(x += y)` вернуло `15`.
  - Второе подвыражение `(x -= 2)` вернуло `13`.

Таким образом, итоговое значение переменной `z` будет:

```csharp
z = 15 + 13; // z = 28
```

**Итоговые значения переменных:**
- `x = 13` (после всех операций присваивания).
- `z = 28` (результат сложения двух значений).

---

Знание приоритета операторов и их ассоциативности является важным аспектом программирования на C#. Эти знания позволяют предсказуемо управлять порядком выполнения операций, особенно в сложных выражениях. Тернарный оператор, арифметические и логические операции, операторы присваивания — все они играют ключевую роль в создании логики программы.

**Основные моменты:**
- **Приоритет операторов** определяет, какие операции выполняются первыми в сложных выражениях.
- **Ассоциативность операторов** определяет порядок выполнения операций, когда несколько операторов с одинаковым приоритетом следуют друг за другом.
- **Понимание этих принципов** позволяет писать более чистый, эффективный и предсказуемый код, избегая ошибок, связанных с неверной интерпретацией порядка выполнения операций.

Эти знания помогают разрабатывать надежные и легко поддерживаемые программы, где каждое выражение выполняется так, как задумано, без неожиданных результатов.

---

## 4. Работа с типами данных и преобразования

---

### 4.1 Явные и неявные преобразования типов

Преобразование типов данных — это процесс приведения значения одного типа к другому типу. В C# различают два основных вида преобразования: **неявное** и **явное**. Понимание этих механизмов важно для эффективного и безопасного использования различных типов данных, особенно при работе с числовыми типами, объектами, а также при взаимодействии с различными API и библиотеками.

#### **Неявное преобразование: автоматическое приведение типов**

**Неявное преобразование** происходит автоматически, без явного указания разработчика. Это преобразование выполняется компилятором, когда он уверен, что преобразование безопасно и не приведет к потере данных. Обычно неявное преобразование возможно, когда целевой тип имеет больший или равный диапазон значений по сравнению с исходным типом.

**Основные характеристики неявного преобразования:**
- Безопасность: Неявное преобразование гарантирует отсутствие потери данных.
- Простота: Код становится более читаемым, так как разработчику не нужно явно указывать преобразование.

**Примеры неявного преобразования:**

1. **Преобразование от `int` к `double`:**
   ```csharp
   int intValue = 42;
   double doubleValue = intValue;  // Неявное преобразование от int к double
   ```

   **Описание:**
   - В этом примере значение переменной `intValue` типа `int` автоматически приводится к типу `double` и сохраняется в переменной `doubleValue`.
   - Так как `double` может хранить все целые числа, преобразование безопасно и не приводит к потере данных.

2. **Преобразование от `float` к `double`:**
   ```csharp
   float floatValue = 3.14f;
   double doubleValue = floatValue;  // Неявное преобразование от float к double
   ```

   **Описание:**
   - Значение переменной `floatValue` автоматически приводится к типу `double`.
   - Так как `double` имеет большую точность и диапазон, чем `float`, преобразование также безопасно.

#### **Явное преобразование: использование операторов приведения (`(int)`, `(double)` и др.)**

**Явное преобразование** требует явного указания приведения типов с использованием операторов приведения, так как компилятор не может гарантировать безопасность преобразования. Явное преобразование необходимо, когда существует риск потери данных, или когда разработчик намеренно хочет изменить тип данных.

**Основные характеристики явного преобразования:**
- Возможная потеря данных: Явное преобразование может привести к утрате информации, если исходный тип имеет больше значений или более высокую точность, чем целевой.
- Необходимость использования оператора приведения: Для выполнения явного преобразования необходимо явно указать тип, к которому нужно привести значение.

**Примеры явного преобразования:**

1. **Преобразование от `double` к `int`:**
   ```csharp
   double doubleValue = 42.9;
   int intValue = (int)doubleValue;  // Явное преобразование от double к int
   ```

   **Описание:**
   - В этом примере значение переменной `doubleValue` явно приводится к типу `int`.
   - Преобразование приводит к потере дробной части числа (`42.9` становится `42`).

2. **Преобразование от `long` к `int`:**
   ```csharp
   long longValue = 100000;
   int intValue = (int)longValue;  // Явное преобразование от long к int
   ```

   **Описание:**
   - Здесь значение типа `long` явно приводится к типу `int`.
   - Если значение `longValue` превышает диапазон типа `int` (от `-2,147,483,648` до `2,147,483,647`), это может привести к некорректному результату.

#### **Примеры ошибок при неправильном преобразовании**

Ошибки при преобразовании типов могут привести к некорректным данным, исключениям во время выполнения программы, или даже к непредсказуемому поведению. Рассмотрим несколько распространенных ошибок.

1. **Потеря данных при преобразовании `double` в `int`:**
   ```csharp
   double doubleValue = 1234.56;
   int intValue = (int)doubleValue;  // intValue = 1234, дробная часть утрачена
   ```

   **Ошибка:**
   - При преобразовании числа с плавающей запятой (типа `double`) в целое число (типа `int`) дробная часть числа отбрасывается.
   - В этом примере значение `1234.56` будет преобразовано в `1234`, что может привести к непредвиденным результатам, если дробная часть важна.

2. **Переполнение при преобразовании `long` в `int`:**
   ```csharp
   long longValue = 3000000000;
   int intValue = (int)longValue;  // intValue получит некорректное значение
   ```

   **Ошибка:**
   - Переменная `longValue` содержит значение, которое превышает максимальное значение типа `int` (2,147,483,647).
   - При явном приведении к `int`, значение переменной `intValue` будет некорректным из-за переполнения (например, оно может стать отрицательным или получить неожиданные значения).

3. **Невозможность выполнения неявного преобразования:**
   ```csharp
   double doubleValue = 42.0;
   int intValue = doubleValue;  // Ошибка компиляции: требуется явное приведение типов
   ```

   **Ошибка:**
   - Компилятор не позволяет выполнить неявное преобразование от `double` к `int`, так как существует риск потери данных.
   - Для выполнения преобразования необходимо явно указать приведение с помощью оператора `(int)`.

4. **Неявное преобразование `int` к `byte` с переполнением:**
   ```csharp
   int intValue = 256;
   byte byteValue = (byte)intValue;  // byteValue = 0 из-за переполнения
   ```

   **Ошибка:**
   - Тип `byte` может хранить значения в диапазоне от 0 до 255. Значение `256` выходит за этот диапазон.
   - При явном приведении происходит переполнение, и результат оказывается равен 0, что может вызвать неожиданные ошибки в программе.

5. **Ошибка при преобразовании строк в числа:**
   ```csharp
   string strValue = "123abc";
   int intValue = int.Parse(strValue);  // Исключение: FormatException
   ```

   **Ошибка:**
   - Метод `int.Parse` пытается преобразовать строку `strValue` в целое число.
   - Если строка содержит недопустимые символы (не являющиеся цифрами), как в этом примере, выбрасывается исключение `FormatException`.
   - Для безопасного преобразования следует использовать метод `int.TryParse`, который возвращает `true` или `false` в зависимости от успеха преобразования, а не выбрасывает исключение.

```csharp
string strValue = "123abc";
int result;
bool success = int.TryParse(strValue, out result);  // success = false, result = 0
```

В этом варианте используется `TryParse`, который предотвращает исключение и позволяет обработать ошибку преобразования корректно.

---

Явные и неявные преобразования типов в C# позволяют гибко управлять типами данных, обеспечивая как удобство программирования, так и безопасность. Понимание этих механизмов помогает избежать ошибок, связанных с потерей данных или некорректными преобразованиями, и позволяет писать надежный и предсказуемый код. Прежде чем выполнять преобразование типов, важно оценить потенциальные риски и выбрать правильный метод приведения, чтобы гарантировать корректное поведение программы.
### 4.2 Преобразования и приведение типов

---

#### 4.2.1 Преобразование строк в числа и обратно

В C# часто возникает необходимость преобразовывать строки в числа и наоборот. Эти операции полезны в различных сценариях, таких как работа с пользовательским вводом, обработка данных из текстовых файлов, парсинг чисел из строк и обратно. 

Преобразование строк в числа и чисел в строки может выполняться несколькими способами, в зависимости от требований к обработке ошибок, гибкости и производительности.

##### **Преобразование строк в числа**

**1. Использование `Convert.ToInt32`**

Метод `Convert.ToInt32` является частью базовой библиотеки .NET и используется для преобразования объекта (обычно строки) в число типа `int`. Этот метод может обрабатывать значения `null` и возвращает `0` в случае, если строка равна `null`. Если строка содержит недопустимые символы или находится в неверном формате, выбрасывается исключение `FormatException`.

**Пример использования:**
```csharp
string strValue = "123";
int intValue = Convert.ToInt32(strValue);
Console.WriteLine(intValue);  // Вывод: 123
```

**Особенности:**
- Возвращает целое число, преобразованное из строки.
- При попытке преобразования некорректного значения выбрасывает исключения `FormatException` или `OverflowException`.
- Если входное значение `null`, возвращается `0`.

**2. Использование `int.Parse`**

Метод `int.Parse` также используется для преобразования строки в целое число. В отличие от `Convert.ToInt32`, этот метод требует, чтобы строка содержала допустимое числовое значение. Если строка является `null` или содержит недопустимые символы, метод выбрасывает исключение.

**Пример использования:**
```csharp
string strValue = "456";
int intValue = int.Parse(strValue);
Console.WriteLine(intValue);  // Вывод: 456
```

**Особенности:**
- Более строгий, чем `Convert.ToInt32`, требует, чтобы строка содержала корректное числовое значение.
- При попытке преобразования некорректного значения выбрасывает исключение `FormatException`.
- Если строка `null`, выбрасывается исключение `ArgumentNullException`.

**3. Использование `int.TryParse`**

Метод `int.TryParse` является безопасным способом преобразования строки в целое число. Вместо того чтобы выбрасывать исключение при ошибке преобразования, метод возвращает булевое значение (`true` или `false`), указывающее на успешность преобразования. Если преобразование успешно, результат сохраняется в переменной, переданной по ссылке через `out`.

**Пример использования:**
```csharp
string strValue = "789";
int intValue;
bool success = int.TryParse(strValue, out intValue);

if (success)
{
    Console.WriteLine($"Conversion succeeded: {intValue}");  // Вывод: 789
}
else
{
    Console.WriteLine("Conversion failed.");
}
```

**Особенности:**
- Безопасен для использования с некорректными строками.
- Возвращает `true` при успешном преобразовании, и `false` при неудаче.
- Избегает выброса исключений, что делает его подходящим для сценариев, где важно производить валидацию пользовательского ввода или данных.

##### **Преобразование чисел в строки**

**1. Использование `ToString()`**

Метод `ToString()` доступен для всех примитивных типов данных и объектов в C#. Он преобразует числовое значение в строковое представление.

**Пример использования:**
```csharp
int intValue = 123;
string strValue = intValue.ToString();
Console.WriteLine(strValue);  // Вывод: "123"
```

**Особенности:**
- Простой и удобный способ преобразования чисел в строки.
- Можно использовать перегрузки `ToString()` для форматирования чисел.

**2. Использование интерполяции строк**

Интерполяция строк (строковые шаблоны) позволяет легко вставлять числовые значения в строку.

**Пример использования:**
```csharp
int intValue = 456;
string strValue = $"The number is {intValue}";
Console.WriteLine(strValue);  // Вывод: "The number is 456"
```

**Особенности:**
- Удобна для создания строк, содержащих несколько переменных.
- Поддерживает форматирование чисел прямо в строке.

**3. Использование метода `string.Format`**

Метод `string.Format` предоставляет гибкий способ форматирования строк, позволяя вставлять числовые значения в строки и управлять их форматированием.

**Пример использования:**
```csharp
int intValue = 789;
string strValue = string.Format("The number is {0}", intValue);
Console.WriteLine(strValue);  // Вывод: "The number is 789"
```

**Особенности:**
- Удобен для форматирования сложных строк.
- Поддерживает различные варианты форматирования чисел.

---

#### **4.2.2 Методы `Convert.ToInt32`, `int.Parse`, `int.TryParse`**

Рассмотрим подробнее каждый из методов преобразования строки в целое число, их особенности, преимущества и недостатки.

##### **1. `Convert.ToInt32`**

Метод `Convert.ToInt32` преобразует значение в целое число типа `int`. Этот метод принимает строку, содержащую числовое значение, или объект, поддерживающий интерфейс `IConvertible`. В случае строки метод пытается преобразовать ее в число. Если строка `null`, возвращается значение `0`.

**Пример использования:**
```csharp
string strValue = "123";
int intValue = Convert.ToInt32(strValue);  // intValue = 123
```

**Особенности:**
- При преобразовании `null` возвращает `0`, а не выбрасывает исключение.
- Выбрасывает исключения `FormatException`, если строка содержит недопустимые символы, или `OverflowException`, если значение выходит за пределы типа `int`.

##### **2. `int.Parse`**

Метод `int.Parse` предназначен для преобразования строки в целое число. Он более строгий, чем `Convert.ToInt32`, и требует, чтобы строка содержала только числовые символы. Метод выбрасывает исключения, если строка содержит недопустимые символы или является `null`.

**Пример использования:**
```csharp
string strValue = "456";
int intValue = int.Parse(strValue);  // intValue = 456
```

**Особенности:**
- Строгий метод, требующий корректного формата строки.
- Выбрасывает `FormatException`, если строка содержит недопустимые символы.
- Выбрасывает `ArgumentNullException`, если строка `null`.
- Выбрасывает `OverflowException`, если значение выходит за пределы допустимого диапазона для типа `int`.

##### **3. `int.TryParse`**

Метод `int.TryParse` — это безопасный способ преобразования строки в целое число. Вместо выбрасывания исключения, метод возвращает булевое значение, указывающее, было ли преобразование успешным. Результат преобразования возвращается через параметр `out`.

**Пример использования:**
```csharp
string strValue = "789";
int intValue;
bool success = int.TryParse(strValue, out intValue);

if (success)
{
    Console.WriteLine($"Conversion succeeded: {intValue}");  // Вывод: 789
}
else
{
    Console.WriteLine("Conversion failed.");
}
```

**Особенности:**
- Безопасен, так как не выбрасывает исключения.
- Возвращает `true`, если преобразование успешно, и `false` в случае неудачи.
- Подходит для проверки пользовательского ввода и других данных, которые могут содержать ошибки.

---

#### **4.2.3 Пример кода с различными методами приведения типов**

Рассмотрим практический пример, в котором используются разные методы преобразования строки в число и наоборот.

**Пример:**
```csharp
using System;

public class Program
{
    public static void Main()
    {
        string[] stringValues = { "123", "456.78", "Hello", null, "2147483648" };
        
        foreach (string strValue in stringValues)
        {
            // Пример с Convert.ToInt32
            try
            {
                int intValue1 = Convert.ToInt32(strValue);
                Console.WriteLine($"Convert.ToInt32: {strValue} -> {intValue1}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Convert.ToInt32: {strValue} -> Error: {ex.Message}");
            }

            // Пример с int.Parse
            try
            {
                int intValue2 = int.Parse(strValue);
                Console.WriteLine($"int.Parse: {strValue} -> {intValue2}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"int.Parse: {strValue} -> Error: {ex.Message}");
            }

            // Пример с int.TryParse
            if (int.TryParse(strValue, out int intValue3))
            {
                Console.WriteLine($"int.TryParse: {strValue} -> {intValue3}");
            }
            else
            {
                Console.WriteLine($"int.TryParse: {strValue} -> Conversion failed");
            }

            Console.WriteLine();
        }

        // Преобразование чисел в строки
        int number = 789;
        string strFromNumber = number.ToString();
        Console.WriteLine($"ToString: {number} -> {strFromNumber}");

        string formattedString = string.Format("Number: {0}, Hex: {0:X}", number);
        Console.WriteLine($"string.Format: {formattedString}");

        string interpolatedString = $"Interpolated number: {number}";
        Console.WriteLine(interpolatedString);
    }
}
```

#### **Описание примера кода:**

1. **Преобразование строк в числа:**
   - **Цикл `foreach`:** Для каждой строки из массива `stringValues` пробуем выполнить три вида преобразования строки в число (`int`).
   
   **a. Преобразование с использованием `Convert.ToInt32`:**
   - Применяется метод `Convert.ToInt32`. Если строка содержит некорректные данные (например, буквы или `null`), метод выбрасывает исключение, которое мы обрабатываем и выводим сообщение об ошибке.

   **b. Преобразование с использованием `int.Parse`:**
   - Применяется метод `int.Parse`. Этот метод также выбрасывает исключение, если строка не может быть корректно преобразована в число. Мы обрабатываем и эти исключения, выводя соответствующие сообщения.

   **c. Преобразование с использованием `int.TryParse`:**
   - Применяется метод `int.TryParse`. Вместо выбрасывания исключений, метод возвращает `true` или `false` в зависимости от успешности преобразования. Результат выводится на консоль. Если преобразование не удалось, выводится сообщение о неудаче.

2. **Преобразование чисел в строки:**
   - **`ToString()`:** Пример преобразования числа в строку с использованием метода `ToString()`. Это стандартный метод для получения строкового представления числового значения.
   - **`string.Format`:** Форматирование строки с использованием `string.Format`, позволяющее включать числовые значения в строку и задавать формат (в данном случае десятичный и шестнадцатеричный).
   - **Интерполяция строк:** Пример интерполяции строки, позволяющей удобно включать переменные непосредственно в строку.

#### **Результат выполнения кода:**

Для массива строк `stringValues`:

1. **Для строки `"123"`:**
   - **Convert.ToInt32:** Успешно преобразует в `123`.
   - **int.Parse:** Успешно преобразует в `123`.
   - **int.TryParse:** Успешно преобразует в `123`.

2. **Для строки `"456.78"`:**
   - **Convert.ToInt32:** Выбросит исключение `FormatException`, так как строка содержит дробную часть.
   - **int.Parse:** Также выбросит исключение `FormatException`.
   - **int.TryParse:** Вернет `false`, указав, что преобразование не удалось.

3. **Для строки `"Hello"`:**
   - **Convert.ToInt32:** Выбросит исключение `FormatException`, так как строка содержит недопустимые символы.
   - **int.Parse:** Также выбросит исключение `FormatException`.
   - **int.TryParse:** Вернет `false`, указав, что преобразование не удалось.

4. **Для строки `null`:**
   - **Convert.ToInt32:** Вернет `0`, так как `null` преобразуется в `0` в данном методе.
   - **int.Parse:** Выбросит исключение `ArgumentNullException`.
   - **int.TryParse:** Вернет `false`, указав, что преобразование не удалось.

5. **Для строки `"2147483648"` (выходит за пределы `int`):**
   - **Convert.ToInt32:** Выбросит исключение `OverflowException`, так как значение выходит за пределы допустимого диапазона типа `int`.
   - **int.Parse:** Также выбросит исключение `OverflowException`.
   - **int.TryParse:** Вернет `false`, указав, что преобразование не удалось.

#### **Вывод:**
- `Convert.ToInt32` и `int.Parse` эффективны для преобразования строк, которые гарантированно содержат допустимые числовые значения, но они выбрасывают исключения при ошибке, что требует обработки.
- `int.TryParse` является безопасным и предпочтительным методом в ситуациях, когда возможен некорректный ввод данных, так как он не выбрасывает исключения и позволяет легко проверять успешность преобразования.
- При преобразовании чисел в строки `ToString`, `string.Format`, и интерполяция строк предоставляют удобные и гибкие способы форматирования и работы со строками в C#.

### 4.3 Оператор `is` и паттерн matching

---

В C# оператор `is` и возможности паттерн-матчинга (pattern matching) предоставляют мощные инструменты для проверки типов объектов во время выполнения программы и работы с ними на основе их типов и значений. Эти механизмы позволяют значительно упростить код, сделать его более выразительным и избежать избыточных преобразований типов.

#### **4.3.1 Проверка типов во время выполнения**

Оператор `is` используется для проверки, соответствует ли объект или переменная указанному типу во время выполнения программы. Это особенно полезно в случаях, когда переменная может содержать значения разных типов (например, переменные типа `object` или в полиморфных структурах).

**Синтаксис:**
```csharp
if (obj is Type)
{
    // Логика обработки
}
```

- **`obj`** — это объект или переменная, тип которого проверяется.
- **`Type`** — это тип данных, на соответствие которому проверяется объект.

Если объект `obj` имеет указанный тип (или может быть приведен к этому типу), то выражение `obj is Type` вернет `true`, иначе — `false`.

#### **4.3.2 Примеры использования оператора `is`**

Оператор `is` широко используется в C# для проверки типов во время выполнения. Рассмотрим несколько примеров его применения.

**Пример 1: Проверка типа объекта**
```csharp
object obj = "Hello, World!";

if (obj is string)
{
    Console.WriteLine("The object is a string.");
}
else
{
    Console.WriteLine("The object is not a string.");
}
```

**Описание:**
- В этом примере переменная `obj` имеет тип `object`, но фактически содержит строку.
- Оператор `is` проверяет, является ли `obj` строкой. В данном случае проверка успешна, и на консоль выводится сообщение `"The object is a string."`.

**Пример 2: Проверка и приведение типа**
```csharp
object obj = 123;

if (obj is int number)
{
    Console.WriteLine($"The object is an integer: {number}");
}
else
{
    Console.WriteLine("The object is not an integer.");
}
```

**Описание:**
- Здесь переменная `obj` также имеет тип `object`, но содержит целое число.
- Важно отметить, что, начиная с C# 7.0, оператор `is` может не только проверять тип, но и выполнять приведение типа, если проверка успешна.
- В данном примере, если `obj` действительно является `int`, оно приводится к целому числу и сохраняется в переменной `number`, которая затем используется в блоке кода.

**Пример 3: Проверка интерфейса**
```csharp
interface IExample { void Execute(); }

class ExampleClass : IExample
{
    public void Execute()
    {
        Console.WriteLine("Executing example.");
    }
}

object obj = new ExampleClass();

if (obj is IExample example)
{
    example.Execute();
}
else
{
    Console.WriteLine("The object does not implement IExample.");
}
```

**Описание:**
- В этом примере переменная `obj` содержит объект класса `ExampleClass`, который реализует интерфейс `IExample`.
- Оператор `is` проверяет, реализует ли объект интерфейс `IExample`. Если проверка успешна, объект приводится к интерфейсу и метод `Execute` вызывается.

#### **4.3.3 Паттерн-матчинг в C# и его использование**

Паттерн-матчинг (pattern matching) в C# — это мощный инструмент, который расширяет возможности оператора `is` и других конструкций, таких как `switch`, позволяя работать с объектами на основе их типов и структуры. С введением C# 7.0 и последующих версий, паттерн-матчинг стал ключевым элементом языка, предоставляя возможности для более гибкой и выразительной работы с данными.

##### **Паттерны в C#**

В C# существуют различные типы паттернов, которые могут использоваться для проверки типов и их значений:

1. **Constant pattern**: Проверяет, соответствует ли значение конкретному константному значению.
2. **Type pattern**: Проверяет, соответствует ли объект определенному типу и одновременно приводит его к этому типу.
3. **Var pattern**: Позволяет присвоить переменной значение объекта без его приведения.
4. **Property pattern**: Позволяет проверять и деструктурировать объекты по их свойствам.
5. **Tuple pattern**: Проверяет и деструктурирует кортежи по их элементам.

##### **Примеры использования паттерн-матчинга**

**Пример 1: Использование `switch` с паттерн-матчингом**
```csharp
object obj = 42;

switch (obj)
{
    case int i:
        Console.WriteLine($"It's an integer: {i}");
        break;
    case string s:
        Console.WriteLine($"It's a string: {s}");
        break;
    case null:
        Console.WriteLine("It's null");
        break;
    default:
        Console.WriteLine("Unknown type");
        break;
}
```

**Описание:**
- В этом примере используется конструкция `switch` с паттерн-матчингом.
- В зависимости от типа `obj`, выполняется соответствующий блок кода. Если `obj` является `int`, оно приводится к целому числу и выводится его значение. Если это строка (`string`), выводится строка, и так далее.
- Это пример использования **type pattern**.

**Пример 2: Использование `if` с property pattern**
```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

object obj = new Person { Name = "John", Age = 30 };

if (obj is Person { Name: "John", Age: >= 18 })
{
    Console.WriteLine("It's John and he's an adult.");
}
```

**Описание:**
- В этом примере используется property pattern для проверки свойств объекта `Person`.
- Проверяется, является ли объект `Person`, и если да, соответствуют ли его свойства заданным условиям: имя должно быть `"John"`, а возраст — не менее 18 лет.
- Если обе проверки успешны, выводится соответствующее сообщение.

**Пример 3: Использование `switch` с tuple pattern**
```csharp
(int x, int y) point = (10, 20);

string quadrant = point switch
{
    ( > 0, > 0) => "First quadrant",
    ( < 0, > 0) => "Second quadrant",
    ( < 0, < 0) => "Third quadrant",
    ( > 0, < 0) => "Fourth quadrant",
    _ => "On the axis or origin"
};

Console.WriteLine($"The point is in the {quadrant}.");
```

**Описание:**
- В этом примере используется tuple pattern для работы с кортежами.
- В зависимости от значений `x` и `y`, определяющих точку на плоскости, определяется, в какой четверти находится точка.
- Если точка находится в первой четверти (оба значения положительные), возвращается соответствующая строка. Аналогично проверяются остальные случаи.
- `_` используется для обработки оставшихся случаев, когда точка лежит на оси или в начале координат.

#### **Заключение**

Оператор `is` и паттерн-матчинг в C# предоставляют мощные инструменты для проверки типов и работы с объектами на основе их типов и значений. Эти возможности делают код более выразительным и компактным, уменьшая количество необходимого кода для выполнения часто встречающихся задач, связанных с обработкой типов. С использованием паттерн-матчинга код становится не только короче, но и легче читаемым и поддерживаемым.

---

## 5. Управление ошибками в выражениях

---

### 5.1 Исключения и обработка ошибок

Обработка ошибок — это важный аспект программирования, который позволяет создавать устойчивые приложения, способные корректно реагировать на неожиданные ситуации. В C# механизм исключений (`exceptions`) предоставляет мощный и гибкий способ обработки ошибок, возникающих в ходе выполнения программы. Исключения позволяют отделить код обработки ошибок от основного кода, улучшая его читаемость и поддерживаемость.

#### **Введение в механизм исключений**

Исключение — это событие, которое возникает во время выполнения программы и нарушает нормальное выполнение инструкции. В C#, когда происходит ошибка, программа создает объект исключения и передает его системе выполнения. Этот процесс называется **выбрасыванием исключения** (throwing an exception).

Исключение может быть вызвано различными причинами:
- Деление на ноль (`DivideByZeroException`).
- Обращение к неинициализированной переменной (`NullReferenceException`).
- Выход за пределы массива (`IndexOutOfRangeException`).
- Неправильный формат данных (`FormatException`).
- Превышение допустимого диапазона числового значения (`OverflowException`).
- И многие другие.

Когда исключение не обрабатывается, программа завершает свою работу с ошибкой, что недопустимо для критически важных приложений. Поэтому C# предоставляет механизм для **обработки исключений**, который позволяет программе восстановиться после возникновения ошибки.

#### **Обработка исключений с использованием блоков `try`, `catch`, `finally`**

Механизм обработки исключений в C# основан на использовании блоков `try`, `catch` и `finally`. Эти блоки позволяют "ловить" исключения, обрабатывать их и выполнять необходимую завершающую логику.

- **`try` блок**: Код, который может вызвать исключение, помещается в блок `try`.
- **`catch` блок**: Если исключение возникает, выполнение переходит к соответствующему блоку `catch`, где исключение обрабатывается.
- **`finally` блок**: Необязательный блок, который выполняется в любом случае после выполнения блоков `try` и `catch`, независимо от того, произошло исключение или нет. Обычно используется для освобождения ресурсов (например, закрытие файлов, освобождение памяти).

**Синтаксис:**
```csharp
try
{
    // Код, который может вызвать исключение
}
catch (ExceptionType1 ex)
{
    // Обработка исключения типа ExceptionType1
}
catch (ExceptionType2 ex)
{
    // Обработка исключения типа ExceptionType2
}
finally
{
    // Код, который выполнится в любом случае
}
```

**Объяснение:**
- `try`: В этом блоке находится основной код, который может вызвать исключение. Если исключение возникает, выполнение программы переходит к соответствующему блоку `catch`.
- `catch`: В зависимости от типа исключения, выполнение переходит к соответствующему блоку `catch`, где исключение обрабатывается. Можно определить несколько блоков `catch` для обработки различных типов исключений.
- `finally`: Этот блок выполняется всегда, независимо от того, произошло исключение или нет. Он полезен для завершения операций, которые должны быть выполнены в любом случае (например, закрытие файлов, освобождение ресурсов).

#### **Примеры кода с обработкой исключений**

Рассмотрим несколько примеров использования блоков `try`, `catch` и `finally` для обработки исключений.

**Пример 1: Обработка деления на ноль**
```csharp
class Program
{
    static void Main()
    {
        try
        {
            int numerator = 10;
            int denominator = 0;
            int result = numerator / denominator;  // Здесь возникнет исключение
            Console.WriteLine($"Result: {result}");
        }
        catch (DivideByZeroException ex)
        {
            Console.WriteLine("Error: Division by zero is not allowed.");
        }
    }
}
```

**Описание:**
- В этом примере код, выполняющий деление на ноль, помещен в блок `try`.
- Когда выполнение доходит до строки `int result = numerator / denominator;`, возникает исключение `DivideByZeroException`, так как деление на ноль недопустимо.
- Исключение перехватывается в блоке `catch`, где выводится сообщение об ошибке: `"Error: Division by zero is not allowed."`.
- Программа продолжает выполнение, избегая аварийного завершения.

**Пример 2: Обработка неправильного формата данных**
```csharp
class Program
{
    static void Main()
    {
        try
        {
            Console.Write("Enter a number: ");
            string userInput = Console.ReadLine();
            int number = int.Parse(userInput);  // Может вызвать исключение
            Console.WriteLine($"You entered: {number}");
        }
        catch (FormatException ex)
        {
            Console.WriteLine("Error: The input is not a valid number.");
        }
    }
}
```

**Описание:**
- Здесь пользователь вводит строку, которая затем пытается быть преобразована в целое число с использованием метода `int.Parse`.
- Если пользователь вводит строку, которая не может быть преобразована в целое число (например, `"abc"`), возникает исключение `FormatException`.
- Исключение перехватывается и обрабатывается в блоке `catch`, где выводится сообщение об ошибке: `"Error: The input is not a valid number."`.

**Пример 3: Использование блока `finally`**
```csharp
class Program
{
    static void Main()
    {
        System.IO.StreamReader file = null;
        try
        {
            file = new System.IO.StreamReader(@"C:\example.txt");
            string content = file.ReadToEnd();
            Console.WriteLine(content);
        }
        catch (System.IO.FileNotFoundException ex)
        {
            Console.WriteLine("Error: File not found.");
        }
        finally
        {
            if (file != null)
            {
                file.Close();  // Гарантированное закрытие файла
                Console.WriteLine("File closed.");
            }
        }
    }
}
```

**Описание:**
- В этом примере программа пытается открыть и прочитать текстовый файл.
- Если файл не найден, выбрасывается исключение `FileNotFoundException`, которое перехватывается и обрабатывается в блоке `catch`.
- Блок `finally` используется для гарантированного закрытия файла, если он был открыт, вне зависимости от того, произошло исключение или нет. Это важно для предотвращения утечек ресурсов.

**Пример 4: Обработка нескольких исключений**
```csharp
class Program
{
    static void Main()
    {
        try
        {
            int[] numbers = { 1, 2, 3 };
            Console.WriteLine(numbers[5]);  // Здесь возникнет исключение IndexOutOfRangeException
        }
        catch (IndexOutOfRangeException ex)
        {
            Console.WriteLine("Error: Index was outside the bounds of the array.");
        }
        catch (Exception ex)
        {
            Console.WriteLine("An unexpected error occurred: " + ex.Message);
        }
    }
}
```

**Описание:**
- В этом примере программа пытается получить доступ к элементу массива по индексу, который выходит за пределы массива, что вызывает исключение `IndexOutOfRangeException`.
- Исключение перехватывается и обрабатывается в соответствующем блоке `catch`.
- Также добавлен общий блок `catch (Exception ex)`, который может перехватывать любые другие исключения, что позволяет обрабатывать неожиданное поведение.

---

Механизм исключений в C# предоставляет мощные инструменты для обработки ошибок, которые позволяют создавать устойчивые и надежные приложения. Использование блоков `try`, `catch` и `finally` помогает разработчикам управлять исключительными ситуациями, обеспечивая правильное завершение операций и защиту от неконтролируемых ошибок. Этот механизм позволяет четко разделять логику программы и код обработки ошибок, что делает код более понятным и поддерживаемым.

### 5.2 Проверка правильности выражений

---

#### **5.2.1 Валидация данных перед выполнением операций**

**Валидация данных** — это процесс проверки входных данных на соответствие определенным требованиям или условиям перед их использованием в выражениях или операциях. Правильная валидация данных предотвращает возникновение ошибок, повышает надежность программного обеспечения и улучшает пользовательский опыт, поскольку многие ошибки можно обнаружить и обработать еще до выполнения потенциально небезопасных операций.

Валидация данных особенно важна в следующих сценариях:
- Обработка пользовательского ввода.
- Взаимодействие с внешними системами и API.
- Операции с файлами и сетевыми ресурсами.
- Математические вычисления и преобразования типов.

##### **Пример: Валидация ввода пользователя**

Рассмотрим ситуацию, когда программа принимает от пользователя число и выполняет с ним вычисления. Перед тем как использовать это число в выражении, необходимо убедиться, что введенные данные являются допустимым числом.

```csharp
class Program
{
    static void Main()
    {
        Console.Write("Enter a number: ");
        string userInput = Console.ReadLine();

        if (int.TryParse(userInput, out int number))
        {
            Console.WriteLine($"You entered the valid number: {number}");
            // Продолжение работы с числом
        }
        else
        {
            Console.WriteLine("Error: The input is not a valid number.");
        }
    }
}
```

**Описание:**
- В этом примере используется метод `int.TryParse`, чтобы проверить, является ли ввод пользователя допустимым целым числом.
- Если ввод корректен, переменная `number` получает значение, и программа может продолжить выполнение.
- Если ввод некорректен, программа выводит сообщение об ошибке и избегает выполнения дальнейших операций с недопустимыми данными.

#### **5.2.2 Использование условий для предотвращения ошибок**

**Условия** в программировании позволяют контролировать поток выполнения программы и предотвращать ошибки, проверяя определенные логические выражения перед выполнением потенциально опасных операций. Это особенно важно в случаях, когда выполнение операции может привести к исключению или некорректным результатам.

**Пример: Проверка деления на ноль**

Одна из наиболее частых ошибок, возникающих при выполнении математических операций, — это деление на ноль. Эта операция приводит к выбросу исключения `DivideByZeroException`. Чтобы предотвратить эту ошибку, необходимо проверять знаменатель перед выполнением операции деления.

```csharp
class Program
{
    static void Main()
    {
        int numerator = 10;
        int denominator = 0;

        if (denominator != 0)
        {
            int result = numerator / denominator;
            Console.WriteLine($"Result: {result}");
        }
        else
        {
            Console.WriteLine("Error: Division by zero is not allowed.");
        }
    }
}
```

**Описание:**
- В этом примере перед выполнением операции деления проверяется условие `denominator != 0`.
- Если знаменатель не равен нулю, выполняется деление, и результат выводится на консоль.
- Если знаменатель равен нулю, программа выводит сообщение об ошибке и предотвращает выполнение некорректной операции.

**Пример: Проверка выхода за пределы массива**

Еще одной распространенной ошибкой является обращение к элементу массива по индексу, который выходит за пределы массива. Это приводит к выбросу исключения `IndexOutOfRangeException`. Для предотвращения этой ошибки необходимо проверять диапазон индекса перед обращением к массиву.

```csharp
class Program
{
    static void Main()
    {
        int[] numbers = { 1, 2, 3 };
        int index = 5;

        if (index >= 0 && index < numbers.Length)
        {
            Console.WriteLine($"Element at index {index}: {numbers[index]}");
        }
        else
        {
            Console.WriteLine("Error: Index is out of range.");
        }
    }
}
```

**Описание:**
- Программа проверяет, находится ли индекс в пределах допустимого диапазона (`index >= 0 && index < numbers.Length`).
- Если индекс допустим, программа выводит значение элемента массива.
- Если индекс выходит за пределы допустимого диапазона, выводится сообщение об ошибке, и попытка обращения к массиву предотвращается.

#### **5.2.3 Логические проверки и вывод сообщений об ошибках**

**Логические проверки** играют ключевую роль в обеспечении корректности выполнения программы. Они позволяют программе принимать решения на основе условий и предотвратить выполнение операций, которые могут привести к ошибкам или некорректным результатам.

##### **Пример: Проверка допустимости значений перед вычислением**

Предположим, что у нас есть программа, которая вычисляет квадратный корень числа. Однако, как известно, вычисление квадратного корня из отрицательного числа в стандартной математике не определено (если не учитывать комплексные числа). Поэтому перед выполнением вычисления необходимо проверить, является ли число неотрицательным.

```csharp
class Program
{
    static void Main()
    {
        Console.Write("Enter a number: ");
        string userInput = Console.ReadLine();

        if (double.TryParse(userInput, out double number))
        {
            if (number >= 0)
            {
                double result = Math.Sqrt(number);
                Console.WriteLine($"The square root of {number} is {result}");
            }
            else
            {
                Console.WriteLine("Error: Cannot compute the square root of a negative number.");
            }
        }
        else
        {
            Console.WriteLine("Error: The input is not a valid number.");
        }
    }
}
```

**Описание:**
- Ввод пользователя сначала проверяется на допустимость методом `double.TryParse`.
- Если ввод является допустимым числом, проверяется, не является ли число отрицательным (`number >= 0`).
- Если число неотрицательное, вычисляется квадратный корень и выводится результат.
- Если число отрицательное, программа выводит сообщение об ошибке и предотвращает некорректное вычисление.

##### **Пример: Логическая проверка условий перед вызовом метода**

Рассмотрим пример, когда программа работает с файлом и должна записывать данные в файл только в том случае, если файл существует и доступен для записи.

```csharp
class Program
{
    static void Main()
    {
        string filePath = @"C:\example.txt";

        if (System.IO.File.Exists(filePath) && IsFileWritable(filePath))
        {
            System.IO.File.WriteAllText(filePath, "Sample text");
            Console.WriteLine("File has been written successfully.");
        }
        else
        {
            Console.WriteLine("Error: File does not exist or is not writable.");
        }
    }

    static bool IsFileWritable(string filePath)
    {
        try
        {
            using (System.IO.FileStream fs = System.IO.File.OpenWrite(filePath))
            {
                return true;
            }
        }
        catch
        {
            return false;
        }
    }
}
```

**Описание:**
- Программа проверяет, существует ли файл и доступен ли он для записи с помощью логического условия `System.IO.File.Exists(filePath) && IsFileWritable(filePath)`.
- Метод `IsFileWritable` пытается открыть файл для записи и возвращает `true`, если это удается, или `false`, если возникают ошибки (например, файл заблокирован другим процессом).
- Если обе проверки успешны, программа записывает текст в файл и выводит сообщение об успешной операции.
- Если файл не существует или не доступен для записи, выводится сообщение об ошибке, и запись в файл предотвращается.

#### **Заключение**

Проверка правильности выражений и валидация данных перед выполнением операций являются важными практиками, которые помогают создать надежные и безопасные программы. Логические проверки, условия и валидация данных позволяют предотвратить возникновение ошибок еще до выполнения операций, что делает программы более устойчивыми и предсказуемыми. Эти меры не только защищают программы от краха, но и улучшают взаимодействие с пользователем, предоставляя более информативные сообщения об ошибках и корректное поведение программы в непредвиденных ситуациях.

---