# Переменные и выражения
Чтобы эффективно использовать C#, важно понимать, что вы на самом деле делаете, когда создаете компьютерную программу. Возможно, самое простое описание компьютерной программы состоит в том, что это серия операций по манипулированию данными. Это справедливо даже для самых сложных примеров, включая обширные многофункциональные приложения Windows (такие как пакет Microsoft Office Suite). Хотя зачастую это полностью скрыто от пользователей приложений, это всегда происходит за кулисами.

Чтобы проиллюстрировать это далее, рассмотрим дисплей вашего компьютера. То, что вы видите на экране, часто настолько знакомо, что трудно представить это чем-то иным, кроме «движущейся картинки». На самом деле то, что вы видите, — это всего лишь представление некоторых данных, которые в своей необработанной форме представляют собой просто поток нулей и единиц, спрятанный где-то в памяти компьютера. Любое действие на экране — перемещение указателя мыши, щелчок по значку, ввод текста в текстовый процессор — приводит к перемещению данных в памяти.

Конечно, и более простые ситуации показывают это так же хорошо. Используя приложение-калькулятор, вы вводите данные в виде чисел и выполняете операции с числами почти так же, как с бумагой и карандашом, но намного быстрее и без шансов на ошибку!

Если компьютерные программы по сути выполняют операции с данными, это означает, что вам нужен способ хранения этих данных и некоторые методы манипулирования ими. Эти две функции предоставляются переменными и выражениями соответственно, и в этой главе рассматривается, что это означает, как в общих, так и в конкретных терминах.

Однако сначала вы рассмотрите базовый синтаксис программирования на C#, поскольку вам нужен контекст, в котором вы сможете изучать и использовать переменные и выражения на языке C#.

## БАЗОВЫЙ СИНТАКСИС C#
Внешний вид кода C# аналогичен коду C++ и Java. Поначалу этот синтаксис может показаться довольно запутанным, и он гораздо меньше похож на письменный английский, чем на некоторые другие языки. Однако, погрузившись в мир программирования на C#, вы обнаружите, что используемый стиль является разумным и можно без особых усилий писать очень читаемый код.

В отличие от компиляторов некоторых других языков, таких как Python, компиляторы C# игнорируют дополнительные пробелы в коде, независимо от того, являются ли они результатом пробелов, возврата каретки или символов табуляции (известных под общим названием пробелов). Это означает, что у вас есть большая свобода в форматировании кода, хотя соблюдение определенных правил может помочь облегчить чтение вашего кода.

Код C# состоит из серии операторов, каждый из которых заканчивается точкой с запятой. Поскольку пробелы игнорируются, несколько операторов могут отображаться в одной строке, хотя для удобства чтения обычно добавляют возврат каретки после точки с запятой, чтобы избежать нескольких операторов в одной строке. Однако вполне приемлемо (и вполне нормально) использовать операторы, занимающие несколько строк кода.

C# — это язык с блочной структурой, то есть операторы являются частью блока кода. Эти блоки, разделенные фигурными скобками 
```
( { } )
```могут содержать любое количество операторов или не содержать их вообще. Обратите внимание, что символы фигурных скобок не нуждаются в сопровождающих точках с запятой.

Например, простой блок кода C# может иметь следующую форму:
```cs
{
<code line 1, statement 1>;
<code line 2, statement 2>
    <code line 3, statement 2>;
}
```
Здесь разделы code line X, statement Y не являются фактическими частями кода C# ; этот текст используется в качестве заполнителя для операторов C#. В этом случае вторая и третья строки кода являются частью одного и того же оператора, поскольку после второй строки нет точки с запятой. Отступ в третьей строке кода позволяет легче понять, что она на самом деле является продолжением второй строки.

В следующем простом примере отступы используются для пояснения самого C#. Это стандартная практика, и фактически Visual Studio автоматически делает это за вас по умолчанию. В общем, каждый блок кода имеет свой уровень отступа, означающий, насколько далеко он находится вправо. Блоки кода могут быть вложены друг в друга (то есть блоки могут содержать другие блоки), и в этом случае вложенные блоки будут иметь дополнительный отступ:
```cs
{
    <code line 1>;
    {
        <code line 2>;
        <code line 3>;
    }
    <code line 4>;
}
```
Кроме того, строки кода, являющиеся продолжением предыдущих строк, обычно также имеют больший отступ, как в третьей строке кода в первом примере кода.

> ПРИМЕЧАНИЕ. Посмотрите в диалоговом окне «Параметры Visual Studio» (выберите «Инструменты» ➪ «Параметры»), чтобы увидеть правила, которые Visual Studio использует для форматирования вашего кода. Их много в подкатегориях узла «Текстовый редактор» ➪ C# ➪ «Стиль кода» ➪ «Форматирование». Большинство настроек здесь отражают части C#, которые еще не были рассмотрены, но вы, возможно, захотите вернуться к этим настройкам позже, если захотите настроить их так, чтобы они лучше соответствовали вашему личному стилю. Для ясности в этой книге показаны все фрагменты кода в том виде, в каком они были бы отформатированы с настройками по умолчанию.

Конечно, этот стиль ни в коем случае не является обязательным. Однако, если вы не воспользуетесь им, вы быстро обнаружите, что по мере изучения курса все может стать очень запутанным!

Комментарии — это еще одна вещь, которую вы часто видите в коде C#. Комментарий, строго говоря, вообще не является кодом C#, но он успешно с ним сосуществует. Комментарии говорят сами за себя: они позволяют добавлять в код описательный текст — на простом английском языке (или французском, немецком, монгольском и т. д.), — который игнорируется компилятором. Когда вы начинаете работать с длинными разделами кода, полезно добавлять напоминания о том, что именно вы делаете, например «эта строка кода запрашивает у пользователя номер» или «этот раздел кода был написан Бенджамином».

C# предоставляет два способа сделать это. Вы можете либо разместить маркеры в начале и конце комментария, либо использовать маркер, который означает, что «все, что находится в остальной части этой строки, является комментарием». Последний метод является исключением из упомянутого ранее правила о том, что компиляторы C# игнорируют возвраты каретки, но это особый случай.

Чтобы указать комментарии с помощью первого метода, вы используете символы /* в начале комментария и символы */ в конце. Они могут встречаться в одной строке или в разных строках, и в этом случае все строки между ними являются частью комментария. Единственное, что вы не можете вводить в тексте комментария, — это */, поскольку он интерпретируется как конечный маркер. Например, допустимо следующее:
```cs
/* This is a comment */
/* And so. . .
. . . is this! */
```
Однако следующее вызывает проблемы:
```cs
/* Comments often end with "*/" characters */
```
Здесь конец комментария (символы после "*/) будет интерпретирован как код C# и возникнут ошибки.

Другой подход к комментированию предполагает начало комментария с // . После этого вы можете писать все, что захотите — лишь бы вы придерживались одной строчки! Следующее нормально:
```cs
// This is a different sort of comment.
```
Однако следующее не удается, поскольку вторая строка интерпретируется как код C#:
```cs
// So is this,
but this bit isn't.
```
Комментирование такого типа полезно для документирования операторов, поскольку оба могут быть размещены в одной строке:
```cs
<A statement>; // Explanation of statement
```
Ранее было сказано, что существует два способа комментирования кода C#, но в C# существует третий тип комментариев — хотя, строго говоря, это расширение синтаксиса //. Вы можете использовать однострочные комментарии, начинающиеся с трех символов / вместо двух, например:
```cs
/// A special comment
```
Обычно они игнорируются компилятором, как и другие комментарии, но вы можете настроить Visual Studio на извлечение текста после этих комментариев и создание специально отформатированного текстового файла при компиляции проекта. Затем вы можете использовать его для создания документации. Для создания этой документации комментарии должны соответствовать правилам документации XML, как описано на [странице](https://learn.microsoft.com/ru-RU/visualstudio/ide/reference/generate-xml-documentation-comments?view=vs-2022) — тема, не затронутая в этом курсе, но которую стоит изучить, если у вас есть немного свободного времени.

Очень важным моментом в коде C# является то, что он чувствителен к регистру. В отличие от некоторых других языков, вы должны вводить код в правильном регистре, поскольку использование прописной буквы вместо строчной помешает компиляции проекта. Например, рассмотрим следующую строку кода, взятую из лекции 1.
```cs
Console.WriteLine("The first app in Beginning C# Programming!");
```
Этот код понимается компилятором C#, поскольку регистр команды Console.WriteLine() правильный. Однако ни одна из следующих строк кода не работает:
```cs
console.WriteLine("The first app in Beginning C# and .NET!");
CONSOLE.WRITELINE("The first app in Beginning C# and .NET!");
Console.Writeline("The first app in Beginning C# and .NET!");
```
Здесь использован неверный регистр, поэтому компилятор C# не будет знать, чего вы хотите. К счастью, как вы вскоре обнаружите, Visual Studio очень полезна при вводе кода и в большинстве случаев знает (насколько может знать программа), что вы пытаетесь сделать. По мере ввода он предлагает команды, которые вы, возможно, захотите использовать, и пытается исправить проблемы с регистром.

## БАЗОВАЯ СТРУКТУРА КОНСОЛЬНОГО ПРИЛОЖЕНИЯ C#
Здесь вы более подробно рассмотрите пример консольного приложения из лекции 1 ( ConsoleApp1 ) и немного разберёте его структуру. Вот код:
```cs
using System;
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            // Output text to the screen.
            Console.WriteLine("Ваше первое приложение на C# и .NET!");
            Console.ReadKey();
        }
    }
}
```
Вы сразу увидите, что здесь присутствуют все синтаксические элементы, обсуждавшиеся в предыдущем разделе — точки с запятой, фигурные скобки и комментарии — вместе с соответствующими отступами.

Самый важный раздел кода сейчас выглядит следующим образом:
```cs
static void Main(string[] args)
    {
        // Output text to the screen.
        Console.WriteLine("Ваше первое приложение на C# и .NET!");
        Console.ReadKey();
    }
```
Это код, который выполняется при запуске консольного приложения. Ну, если быть точнее, выполняется блок кода, заключенный в фигурные скобки. Как упоминалось ранее, строка комментария ничего не делает; это просто для ясности. Две другие строки кода выводят некоторый текст в окно консоли и соответственно ждут ответа, хотя точные механизмы этого пока не должны вас беспокоить.

Функциональность описания кода для приложения Windows — очень полезная функция. Эту функцию можно использовать с ключевыми словами #region и #endregion, которые определяют начало и конец области кода, которую можно развернуть и свернуть. Например, вы можете изменить сгенерированный код для ConsoleApp1 следующим образом:

```cs
#region Using directives
using System;
#endregion
```

Это позволяет вам свернуть этот код в одну строку и снова развернуть его позже, если вы захотите просмотреть детали. Содержащиеся здесь операторы using и оператор пространства имен, расположенный ниже, объясняются в конце лекции.

> ПРИМЕЧАНИЕ. Любое ключевое слово, начинающееся с #, является директивой препроцессора, а не, строго говоря, ключевым словом C#. За исключением двух, описанных здесь, #region и #endregion, они могут быть довольно сложными и имеют очень специализированное применение. Это одна из тем, которую вы, возможно, захотите изучить самостоятельно после изучения курса. Подробнее о них можно прочитать [здесь](https://docs.microsoft.com/ru-RU/dotnet/csharp/language-reference/preprocessor-directives).

На данный момент не беспокойтесь о другом коде в примере, потому что цель этих первых нескольких глав — объяснить базовый синтаксис C#, поэтому точный метод того, как выполнение приложения доходит до точки, где используется Console.WriteLine(). Позже значение этого дополнительного кода будет разъяснено.

## ЛИТЕРАЛЫ

Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными. И отдельный литерал представляет ключевое слово null.

### Логические литералы
Есть две логических константы - true (истина) и false (ложь):
```cs 
Console.WriteLine(true);
Console.WriteLine(false);
```
### Целочисленные литералы
Целочисленные литералы представляют положительные и отрицательные целые числа, например, 1, 2, 3, 4, -7, -109. Целочисленные литералы могут быть выражены в десятичной, шестнадцатеричной и двоичной форме.

С целыми числами в десятичной форме все должно быть понятно, так как они используются в повседневной жизни:

```cs
Console.WriteLine(-11);
Console.WriteLine(5);
Console.WriteLine(505);
```
Числа в двоичной форме предваряются символами 0b, после которых идет набор из нулей и единиц:
```cs
Console.WriteLine(0b11);        // 3
Console.WriteLine(0b1011);      // 11
Console.WriteLine(0b100001);    // 33
```
Для записи числа в шестнадцатеричной форме применяются символы 0x, после которых идет набор символов от 0 до 9 и от A до F, которые собственно представляют число:

```cs
Console.WriteLine(0x0A);    // 10
Console.WriteLine(0xFF);    // 255
Console.WriteLine(0xA1);    // 161
```
### Вещественные литералы
Вещественные литералы представляют дробные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с фиксированной запятой, при которой дробную часть отделяется от целой части точкой. Например

```out
3.14
100.001
-0.38
```

Также вещественные литералы могут определяться в экспоненциальной форме MEp, где M — мантисса, E - экспонента, которая фактически означает "*10^" (умножить на десять в степени), а p — порядок. Например:

```cs
Console.WriteLine(3.2e3);   // по сути равно 3.2 * 10<sup>3</sup> = 3200
Console.WriteLine(1.2E-1);  // равно 1.2 * 10<sup>-1</sup> = 0.12
```

### Символьные литералы
Символьные литералы представляют одиночные символы. Символы заключаются в одинарные кавычки.

Символьные литералы бывают нескольких видов. Прежде всего это обычные символы:

```
'2'
'A'
'T'
```
Также мы можем передать их вывести на консоль с помощью Console.WriteLine:

```cs
Console.WriteLine('2');
Console.WriteLine('A');
Console.WriteLine('T');
```
Специальную группу представляют управляющие последовательности Управляющая последовательность представляет символ, перед которым ставится слеш. И данная последовательность интерпретируется определенным образом. Наиболее часто используемые последовательности:

'\n' - перевод строки

'\t' - табуляция

'\\' - слеш

И если компилятор встретит в тексте последовательность \t, то он будет воспринимать эту последовательность не как слеш и букву t, а как табуляцию - то есть длинный отступ.

Также символы могут определяться в виде шестнадцатеричных кодов, также заключенный в одинарные кавычки.

Еще один способ определения символов представляет использования шестнадцатеричных кодов ASCII. Для этого в одинарных кавычках указываются символы '\x', после которых идет шестнадцатеричный код символа из таблицы ASCII. Коды символов из таблицы ASCII можно посмотреть здесь.

Например, литерал '\x78' представляет символ "x":

```cs
Console.WriteLine('\x78');    // x
Console.WriteLine('\x5A');    // Z
```
И последний способ определения символьных литералов представляет применение кодов из таблицы символов Unicode. Для этого в одинарных кавычках указываются символы '\u', после которых идет шестнадцатеричный код Unicode. Например, код '\u0411' представляет кириллический символ 'Б':

```cs
Console.WriteLine('\u0420');    // Р
Console.WriteLine('\u0421');    // С
```
### Строковые литералы
Строковые литералы представляют строки. Строки заключаются в двойные кавычки:
```cs
Console.WriteLine("hello");
Console.WriteLine("фыва");
Console.WriteLine("hello word");
```
Если внутри строки необходимо вывести двойную кавычку, то такая внутренняя кавычка предваряется обратным слешем:

```cs
Console.WriteLine("Компания \"Рога и копыта\"");
```
Также в строках можно использовать управляющие последовательности. Например, последовательность '\n' осуществляет перевод на новую строку:

```cs
Console.WriteLine("Привет \nмир");
```
При выводе на консоль слово "мир" будет перенесено на новую строку:
```
Привет
мир
```
### null
null представляет ссылку, которая не указывает ни на какой объект. То есть по сути отсутствие значения.

## ПЕРЕМЕННЫЕ
Как упоминалось ранее, переменные связаны с хранением данных. По сути, вы можете думать о переменных в памяти компьютера как о коробках, стоящих на полке. Вы можете складывать вещи в коробки и вынимать их снова, а можете просто заглянуть внутрь коробки и посмотреть, есть ли там что-нибудь. То же самое касается переменных; вы помещаете в них данные и можете их вынимать или просматривать по мере необходимости.
Хотя все данные в компьютере по сути представляют собой одно и то же (последовательность нулей и единиц), переменные бывают разных видов, известных как типы. Снова используя аналогию с коробками, коробки бывают разных форм и размеров, поэтому некоторые предметы помещаются только в определенные коробки. Причина этой системы типов заключается в том, что разные типы данных могут требовать разных методов манипулирования, и, ограничивая переменные отдельными типами, вы можете избежать их путаницы. Например, не имеет особого смысла рассматривать последовательность нулей и единиц, составляющих цифровое изображение, как аудиофайл.

Чтобы использовать переменные, вы должны их объявить. Это означает, что вы должны присвоить им имя и тип. После объявления переменных вы можете использовать их в качестве единиц хранения данных того типа, для хранения которых вы их объявили.

Синтаксис C# для объявления переменных просто указывает тип и имя переменной:

```cs
int a;
```

Если вы попытаетесь использовать переменную, которая не была объявлена, ваш код не скомпилируется, но в этом случае компилятор точно сообщит вам, в чем проблема, так что на самом деле это не катастрофическая ошибка. Попытка использовать переменную без присвоения ей значения также вызывает ошибку, но, опять же, компилятор это обнаруживает.

### Простые типы
К простым типам относятся такие типы, как числа и логические значения (истина или ложь), которые составляют фундаментальные строительные блоки ваших приложений. В отличие от сложных типов, простые типы не могут иметь дочерних элементов или атрибутов. Большинство доступных простых типов являются числовыми, что на первый взгляд кажется немного странным — ведь для хранения числа нужен только один тип, не так ли?

Причина обилия числовых типов кроется в механизме хранения чисел в памяти компьютера в виде последовательности нулей и единиц. Для целочисленных значений вы просто берете несколько битов (отдельные цифры, которые могут быть 0 или 1) и представляете свое число в двоичном формате. Переменная, хранящая N бит, позволяет вам представлять любое число от 0 до 
$$2^N − 1.$$ 

Любые числа выше этого значения слишком велики, чтобы поместиться в эту переменную.
Например, предположим, что у вас есть переменная, которая может хранить два бита. Таким образом, отображение между целыми числами и битами, представляющими эти целые числа, выглядит следующим образом:

0 = 00

1 = 01

2 = 10

3 = 11

Чтобы хранить больше чисел, вам нужно больше битов (например, три бита позволяют хранить числа от 0 до 7).

Неизбежным результатом этой системы является то, что вам понадобится бесконечное количество битов, чтобы хранить все мыслимые числа, которые не поместятся в ваш верный компьютер. Даже если бы для каждого числа можно было использовать определенное количество битов, было бы неэффективно использовать все эти биты для переменной, которая, например, требовалась для хранения только чисел от 0 до 10 (потому что хранилище быть потрачены впустую). Здесь вполне подойдут четыре бита, позволяющие хранить гораздо больше значений в этом диапазоне в том же пространстве памяти.

Вместо этого для хранения различных диапазонов чисел можно использовать несколько разных целочисленных типов, которые занимают разное количество памяти (до 64 бит). Эти типы показаны в таблице 2-1:

|Тип|Системный тип|Допустимые значения|Байт в памяти|
|---|---------|--------------|:---:|
|sbyte|System.SByte|Integer between −128 and 127|1|
|byte|System.Byte|Integer between 0 and 255|1|
|short|System.Int16|Integer between −32768 and 32767|2|
|ushort|System.UInt16|Integer between 0 and 65535|2|
|int|System.Int32|Integer between −2147483648 and 2147483647|4|
|uint|System.UInt32|Integer between 0 and 4294967295|4|
|long|System.Int64|Integer between −9223372036854775808 and 9223372036854775807|8|
|ulong|System.UInt64|Integer between 0 and 18446744073709551615|8|

Символ u перед именами некоторых переменных является сокращением от unsigned. Это означает, что вы не можете хранить отрицательные числа в переменных этих типов, как показано в столбце «Допустимые значения» таблицы.

Конечно, вам также необходимо хранить значения с плавающей запятой, которые не являются целыми числами. Вы можете использовать три типа переменных с плавающей запятой: float, double и decimal. Первые два хранят числа с плавающей запятой в виде 
$$m × 2^e$$ 
где допустимые значения m и e различаются для каждого типа. в десятичной системе используется альтернативная форма 
$$m × 10^e$$

Эти три типа показаны в Таблице 2-2 вместе с допустимыми значениями m и e, а также ограничениями в действительных числах, показанными в последних двух столбцах таблицы.

| Тип | Системный тип | Допустимые значения | Байт в памяти |
| --- | ------------- | ------------------- | :-----------: |
|float|System.Single|От -3.4 * 10<sup>38</sup> до 3.4 * 10<sup>38</sup>| 4|
|double|System.Double| от ±5.0 * 10<sup>-324</sup> до ±1.7 * 10<sup>308</sup>|8|
|decimal|System.Decimal| хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0 * 10<sup>-28</sup> до ±7.9228 * 10<sup>28</sup>, может хранить 28 знаков после запятой|16|

Помимо числовых типов, доступны еще три простых типа.

| Тип | Системный тип | Что хранит |
| --- | ------------- | -------------------|
|char| System.Char|Хранит одиночный символ в кодировке Unicode и занимает 2 байта.|
|string|System.String|Хранит набор символов Unicode. Этому типу соответствуют строковые литералы|
|bool|System.Boolean|Хранит значение true или false (логические литералы)|

Обратите внимание, что технически не существует верхнего предела количества символов, составляющих строку, поскольку она может использовать разные объемы памяти.
Логический тип bool — один из наиболее часто используемых типов переменных в C#, и действительно, подобные типы столь же часто встречаются в коде на других языках. Наличие переменной, которая может иметь значение true или false, имеет важные последствия, когда речь идет о потоке логики в приложении. В качестве простого примера рассмотрим, на сколько вопросов можно ответить верно или неверно (или да и нет). Выполнение сравнения значений переменных или проверка входных данных — это лишь два программных применения логических переменных, которые вы очень скоро изучите.

Теперь, когда вы познакомились с этими типами, рассмотрим короткий пример их объявления и использования. В следующем примере вы используете простой код, который объявляет две переменные, присваивает им значения, а затем выводит эти значения.
### Использование переменных простого типа
```cs
int myInteger;
string myString;
myInteger = 17;
myString = "\"myInteger\" is";
Console.WriteLine($"{myString} {myInteger}");
Console.ReadKey();
```

```
"myInteger" is 17
```
### Как это работает
Добавленный код выполняет три задачи:

- **Он объявляет две переменные.**

- **Он присваивает значения этим двум переменным.**

- **Он выводит значения двух переменных на консоль.**

Объявление переменной происходит в следующем коде:
```cs
int myInteger;
string myString;
```
В первой строке объявляется переменная типа int с именем myInteger, а во второй строке объявляется переменная типа string с именем myString.

> ПРИМЕЧАНИЕ. Именование переменных ограничено; вы не можете использовать любую последовательность символов. Вы узнаете об этом в разделе «Именование переменных».

Следующие две строки кода присваивают значения:
```cs
myInteger = 17;
myString = "\"myInteger\" is";
```
Здесь вы присваиваете переменным два фиксированных значения (известных в коде как литеральные значения) с помощью оператора присваивания. Вы присвоили целочисленное значение 17 myInteger и присвоили myString следующую строку (включая кавычки):
```
"myInteger" is
```
Когда вы присваиваете значения строковых литералов таким способом, для заключения строки требуются двойные кавычки. Таким образом, некоторые символы могут вызвать проблемы, если они включены в саму строку, например символы двойных кавычек, и вам придется экранировать некоторые символы, заменяя их последовательностью других символов (Escape-последовательность), представляющей символы, которые вы хотите использовать. В этом примере вы используете последовательность \", чтобы избежать двойной кавычки:
```cs
myString = "\"myInteger\" is";
```
Если вы не использовали эти escape-последовательности и попытались закодировать это следующим образом, вы получите ошибку компилятора:
```cs
myString = ""myInteger" is";
```
Обратите внимание, что присвоение строковых литералов — это еще одна ситуация, в которой следует быть осторожным с разрывами строк: компилятор C# отклоняет строковые литералы, занимающие более одной строки. Если вы хотите добавить разрыв строки, используйте escape-последовательность для символа новой строки в вашей строке, то есть \n . Например, рассмотрим следующее задание:
```cs
myString = "This string has a\nline break.";
```
Эта строка будет отображаться в двух строках в представлении консоли следующим образом:
```
This string has a
line break.
```
Все escape-последовательности состоят из символа бэеслеш, за которым следует один из небольшого набора символов (полный набор вы увидите позже). Поскольку этот символ используется для этой цели, для самого символа обратной косой черты также существует escape-последовательность, которая представляет собой просто две последовательные обратные косые черты ( \\ ).

Возвращаясь к коду, есть еще одна новая строка, на которую стоит обратить внимание:
```cs
Console.WriteLine($"{myString} {myInteger}");
```
Знак $ перед двойной кавычкой — это символ, используемый для реализации функции, известной как интерполяция строк, и он похож на простой метод вывода текста на консоль, который вы видели в первом примере, но теперь вы указываете свои переменные. Пока слишком рано углубляться в детали этой строки кода, но достаточно сказать, что именно этот метод вы будете использовать в первой части этой книги для вывода текста в окно консоли.

Этот метод вывода текста на консоль вы используете для отображения вывода вашего кода в следующих примерах. Наконец, код включает строку, показанную в предыдущем примере, для ожидания ввода пользователя перед завершением:
```cs
Console.ReadKey();
```
Опять же, код сейчас не анализируется, но вы часто будете видеть его в последующих примерах. А пока поймите, что выполнение кода приостанавливается до тех пор, пока вы не нажмете клавишу.

## Именование переменных
Как упоминалось в предыдущем разделе, вы не можете просто выбрать любую последовательность символов в качестве имени переменной. Однако это не так тревожно, как может показаться, поскольку у вас по-прежнему остается очень гибкая система именования.

Основные правила именования переменных следующие:
- **Первым символом имени переменной должна быть буква, символ подчеркивания ( _ ) или символ at ( @ ).**
- **Последующие символы могут быть буквами, символами подчеркивания или цифрами.**

Существуют также определенные ключевые слова, которые имеют специальное значение для компилятора C#, например ключевые слова using и namespace, показанные ранее. Однако если вы используете один из них по ошибке, компилятор сообщит об этом, так что не беспокойтесь об этом.
Например, подходят следующие имена переменных:
```cs
myBigVar
VAR1
_test
```
Неверно:
```cs
99BottlesOfBeer
namespace
It's-All-Over
```
В предыдущем уроке были показаны два примера литеральных значений: целое число ( 17 ) и строка (« \"myInteger\" is"). Другие типы переменных также имеют связанные с ними литеральные значения, как показано в Таблице 3-4. Многие из них включают суффиксы, при которых в конец буквального значения добавляется последовательность символов, чтобы указать желаемый тип. Некоторые литералы имеют несколько типов, определяемых компилятором во время компиляции на основе их контекста (также показано в таблице)
|TYPE(S)|CATEGORY|SUFFIX|EXAMPLE/ALLOWED VALUES|
|---|---|---|---|
|Bool|Boolean|None|true or false|
|int, uint, long, ulong|Integer|None|100
|uint, ulong|Integer|u or U|100U|
|long, ulong|Integer|l or L|100L|
|Ulong|Integer|ul, uL, Ul, UL, lu, lU, Lu, or LU|100UL|
|Float|Real|f or F|1.5F|
|double|Real|None, d, or D|1.5|
|decimal|Real|m or M|1.5M|
|char|Character|None|'a', or escape sequence|
|string|String|None|"a…a", may include escape sequences|

## Двоичные литералы и разделители цифр
Независимо от того, насколько изощренным или сложным становится синтаксис программирования, компьютеры функционируют только в двух состояниях: 0 и 1, также известных как двоичные (основание 2). Если бы вы захотели, вы могли бы закодировать все свои программы как последовательность нулей и единиц, а затем запустить эту программу. Хотя это невозможно и не рекомендуется, тем самым вы облегчите интерпретаторам задачу преобразования программы, например, из десятичной (базовая 10), восьмеричной (базовая 8) или шестнадцатеричной (базовая 16). От этого не так уж много пользы, поэтому использование двоичного кода предназначено для очень специфических сценариев, которые этого требуют. Например, вам может потребоваться передать значения в сторонний пакет кода в двоичной, шестнадцатеричной форме или форме ASCII. По большей части, если эти литералы не требуются, вам следует писать код, используя такой язык программирования, как C#.

Глубокие технические знания и историческое понимание полубайтов, битов, байтов, символов, слов, ячеек, шестнадцатеричных, восьмеричных и т. д. необходимы для глубокого понимания того, когда, где, как и почему использовать эти литералы. Вместо того, чтобы углубляться в исторический вопрос «почему» и дискуссии на профессиональном уровне «как», сейчас достаточно знать, что, например, вы можете использовать двоичные литералы как элегантный способ хранения значений в виде констант для сопоставления с образцом. и сравнения, а также для реализации битовых масок. Как показано в примере двоичного и шестнадцатеричного чисел в следующих строках кода, вы можете видеть, что двоичные числа поворачиваются на один бит справа налево. Шестнадцатеричные значения не имеют шаблона, что затрудняет быстрое определение цели кода.
```cs
int[] binaryPhases = { 0b00110001, 0b01100010, 0b11000100, 0b10001001 };
int[] hexPhases = { 0x31, 0x62, 0xC4, 0x89 };
```
Теперь у вас есть некоторый контекст, и вместо того, чтобы слишком быстро углубляться в сопоставление с образцом и битовые маски, оставшаяся часть этого раздела посвящена двоичным литералам C# и цифровым разделителям. Вы можете самостоятельно прочитать больше о сопоставлении двоичных образов и битовых масках, чтобы расширить свои знания после прочтения этой книги и получить больше опыта программирования.

Чтобы лучше понять функцию двоичных литералов C#, возьмем, к примеру, следующий код:
```cs
int[] numbers = {1, 2, 4, 8, 16 };
```

В C# значения, добавленные в массив чисел, могут быть записаны непосредственно в двоичном формате, как показано здесь.

```cs
int[] numbers = { 0b0001, 0b0010, 0b00100, 0b0001000, 0b00010000 };
```
Как и в случае с шестнадцатеричными числами, где префикс равен 0x, компилятор распознает любое значение, начинающееся с 0b, как двоичное значение и обрабатывает его как таковое. Как вы можете себе представить, двоичные значения больших чисел становятся длинными, и при вводе их вручную легко допустить ошибку. Возьмем, к примеру, число 128, которое имеет двоичное значение 10000000, то есть 1, за которой следуют 7 нулей. Здесь могут помочь разделители цифр. В качестве примера возьмем следующий код:
```cs
int[] numbers = { 32, 64, 128 };
int[] numbers = { 0b0010_0000, 0b0100_0000, 0b1000_0000 };
```
Знание того, что вы можете разделить двоичный литерал на группы цифр, помогает улучшить читаемость кода и управление им. Разделители цифр не ограничиваются только двоичными значениями: их также можно использовать с целыми, десятичными, плавающими и двойными значениями. Следующая строка кода представляет значение числа Пи с использованием разделителя после каждой третьей цифры. Основная причина использования разделителей цифр — облегчение чтения кода.

```cs
const double Pi = 3.141_592_653_589_793_238_462_643_383_279_502;
```

## Esc последовательности
Ранее в этой лекции вы видели несколько escape-последовательностей, которые можно использовать в строковых литералах. В Таблице они перечислены для справочных целей.
|ESCAPE SEQUENCE|CHARACTER PRODUCED|UNICODE (HEX) VALUE OF CHARACTER|
|---|---|:---:|
|\\'|Single quotation mark|0x0027|
|\\"|Double quotation mark|0x0022|
|\\|Backslash|0x005C|
|\\0|Null|0x0000|
|\\a|Alert (causes a beep)|0x0007|
|\\b|Backspace|0x0008|
|\\f|Form feed|0x000C|
|\\n|New line|0x000A|
|\\r|Carriage return|0x000D|
|\\t|Horizontal tab|0x0009|
|\\v|Vertical tab|0x000B|

Столбец «Значение символов Юникода» в таблице показывает шестнадцатеричные значения символов в том виде, в котором они находятся в наборе символов Юникода. Помимо ранее описанных escape-последовательностей, вы можете указать любой символ Юникода, используя escape-последовательность Юникода. Они состоят из стандартного символа \, за которым следует символ u и четырехзначное шестнадцатеричное значение (например, четыре цифры после x в Таблице).

Это означает, что следующие строки эквивалентны:

```cs
"Benjamin\'s string."
"Benjamin\u0027s string."
```

Очевидно, что использование escape-последовательностей Unicode дает больше возможностей.

Вы также можете указать строки дословно. Это означает, что в строку включаются все символы, заключенные в две двойные кавычки, включая символы конца строки и символы, которые в противном случае пришлось бы экранировать. Единственным исключением из этого правила является escape-последовательность для символа двойной кавычки, которую необходимо указать, чтобы строка не заканчивалась. Для этого поместите символ @ перед строкой:

```cs
@"Verbatim string literal."
```

Эту строку можно было бы так же легко указать обычным способом, но для следующей строки требуется символ @:
```cs
@"A short list:
item 1
item 2"
```

Дословные строки особенно полезны в именах файлов, поскольку в них используется множество символов обратной косой черты. При использовании обычных строк вам придется использовать двойную обратную косую черту по всей длине строки:

```cs
"C:\\Temp\\MyDir\\MyFile.doc"
```
С помощью дословных строковых литералов вы можете сделать это более читабельным. Следующая дословная строка эквивалентна предыдущей:
```cs
@"C:\Temp\MyDir\MyFile.doc"
```

> ПРИМЕЧАНИЕ. Как будет показано далее, строки являются ссылочными типами. Это контрастирует с другими типами, которые вы видели в этой главе и которые являются типами значений. Одним из последствий этого является то, что строкам также может быть присвоено значение null, что означает, что строковая переменная не ссылается на строку (или на что-либо еще, если на то пошло).

## Операции
C# содержит несколько операторов для выполнения операций над значениями. Комбинируя операторы с переменными и литеральными значениями (при использовании с операторами они называются операндами), вы можете создавать выражения, которые являются основными строительными блоками вычислений.

Доступные операторы варьируются от простых до сложных, с некоторыми из которых вы, возможно, никогда не столкнетесь за пределами математических приложений. Простые включают в себя все основные математические операции, такие как оператор + для сложения двух операндов; сложные включают манипуляции содержимым переменных посредством двоичного представления этого содержимого. Существуют также логические операторы, специально предназначенные для работы с логическими значениями, и операторы присваивания, такие как =.

В этой части основное внимание уделяется математическим операторам и операторам присваивания, оставляя логические для следующей лекции, где вы будете изучать булеву логику в контексте управления потоком программы.
Операторов можно условно разделить на три категории:
- **Унарный — действие с отдельными операндами.**
- **Бинарный — действие с двумя операндами.**
- **Тернарный — действие с тремя операндами.**

Большинство операторов попадают в бинарную категорию: несколько унарных и один троичный, называемый условным оператором (условный оператор является логическим и обсуждается в главе 4). Давайте начнем с рассмотрения математических операторов, которые охватывают как унарные, так и бинарные категории.

### Математические операторы
Существует пять простых математических операторов, два из которых (+ и -) имеют как двоичную, так и унарную форму. В Таблице 3-6 перечислен каждый из этих операторов, краткий пример его использования и результат его использования с простыми числовыми типами (целыми числами и с плавающей запятой).

|OPERATOR|CATEGORY|EXAMPLE EXPRESSION|RESULT|
|---|---|---|---|
|+|Binary|var1 = var2 + var3;|var1 присваивается значение, которое является суммой var2 и var3|
|-|Binary|var1 = var2 - var3;|var1 присваивается значение, которое представляет собой значение var3, вычтенное из значения var2.|
|*|Binary|var1 = var2 * var3;|переменной var1 присваивается значение, которое является произведением var2 и var3|
|/|Binary|var1 = var2 / var3;|переменной var1 присваивается значение, которое является результатом деления var2 на var3|
|%|Binary|var1 = var2 % var3;|var1 присваивается значение, которое является остатком от деления var2 на var3|
|+|Unary|var1 = +var2;|var1 присваивается значение var2|
|-|Unary|var1 = -var2;|var1 присваивается значение var2, умноженное на -1.|

> ПРИМЕЧАНИЕ. Оператор + (унарный) немного странный, поскольку он не влияет на результат. Он не требует, чтобы значения были положительными, как вы могли бы предположить: если var2 равно -1, то +var2 также равно -1. Однако он является общепризнанным оператором и поэтому включен в него. Наиболее полезные факты об этом операторе будут показаны далее, когда вы будете рассматривать перегрузку операторов.

В примерах используются простые числовые типы, поскольку при использовании других простых типов результат может быть неясным. Чего бы вы ожидали, если бы добавили, например, два логических значения? В данном случае ничего, потому что компилятор выдает сообщение, если вы попытаетесь использовать + (или любой другой математический оператор) с логическими переменными. Добавление переменных типа char также немного сбивает с толку. Помните, что переменные типа char хранятся как числа, поэтому добавление двух переменных типа char также приводит к числу (точнее, типа int). Это пример неявного преобразования, о котором вы вскоре узнаете больше (наряду с явным преобразованием), поскольку он также применим к случаям, когда var1, var2 и var3 имеют смешанные типы.

Два других оператора, на которые вам следует здесь обратить внимание, — это операторы увеличения и уменьшения, оба из которых являются унарными операторами, которые можно использовать двумя способами: либо непосредственно перед операндом, либо сразу после него. Результаты, полученные в простых выражениях, показаны в Таблице.

|OPERATOR|CATEGORY|EXAMPLE EXPRESSION|RESULT|
|---|---|---|---|
|++|Unary|var1 = ++var2;|var1 присваивается значение var2 + 1. var2 увеличивается на 1|
|--|Unary|var1 = --var2;|var1 присваивается значение var2-1. var2 уменьшается на 1|
|++|Unary|var1 = var2++;|var1 присваивается значение var2. var2 увеличивается на 1|
|--|Unary|var1 = var2--;|var1 присваивается значение var2. var2 уменьшается на 1|

Эти операторы всегда приводят к изменению значения, хранящегося в их операнде:
- **++ всегда приводит к увеличению операнда на единицу.**
- **−− всегда приводит к уменьшению операнда на единицу.**

Различия между результатами, хранящимися в переменной var1, являются следствием того, что размещение оператора определяет, когда он вступит в силу. Размещение одного из этих операторов перед его операндом означает, что операнд будет затронут до того, как будут произведены любые другие вычисления. Размещение его после операнда означает, что на операнд воздействуют после завершения всех остальных вычислений выражения.

Это заслуживает еще одного примера! Рассмотрим этот код:
```cs
int var1, var2 = 5, var3 = 6;
var1 = var2++ * --var3;
```
Какое значение будет присвоено var1? Перед вычислением выражения вступает в силу оператор --, предшествующий var3, изменяя его значение с 6 на 5. Вы можете игнорировать оператор ++, следующий за var2, поскольку он не вступит в силу до завершения вычисления, поэтому var1 будет произведением 5 и 5 или 25.

Эти простые унарные операторы оказываются очень полезными в удивительном количестве ситуаций. На самом деле это просто сокращение таких выражений, как это:
```cs
var1 = var1 + 1;
```
Выражения такого рода имеют множество применений, особенно когда речь идет о циклах, как показано в следующей лекции. Ниже представлен пример, демонстрирующий использование математических операторов, а также представлены несколько других полезных концепций. Код предлагает ввести строку и два числа, а затем демонстрирует результаты выполнения некоторых вычислений.

```cs
double firstNumber, secondNumber;
string userName;
Console.WriteLine("Enter your name:");
userName = Console.ReadLine();
Console.WriteLine($"Welcome {userName}!");
Console.WriteLine("Now give me a number:");
firstNumber = Convert.ToDouble(Console.ReadLine());
Console.WriteLine("Now give me another number:");
secondNumber = Convert.ToDouble(Console.ReadLine());
Console.WriteLine($"The sum of {firstNumber} and {secondNumber} is " +
$"{firstNumber + secondNumber}.");
Console.WriteLine($"The result of subtracting {secondNumber} from " +
$"{firstNumber} is {firstNumber ‐ secondNumber}.");
Console.WriteLine($"The product of {firstNumber} and {secondNumber} " +
$"is {firstNumber * secondNumber}.");
Console.WriteLine($"The result of dividing {firstNumber} by " +
$"{secondNumber} is {firstNumber / secondNumber}.");
Console.WriteLine($"The remainder after dividing {firstNumber} by " +
$"{secondNumber} is {firstNumber % secondNumber}.");
Console.ReadKey();
```

### Как это работает
Помимо демонстрации математических операторов, этот код знакомит с двумя важными понятиями, с которыми вы часто будете сталкиваться:
- **Пользовательский ввод**
- **Преобразование типов**

Пользовательский ввод использует синтаксис, аналогичный команде Console.WriteLine(), которую вы уже видели — вы используете Console.ReadLine() . Эта команда запрашивает у пользователя ввод, который сохраняется в строковой переменной:
```cs
string userName;
Console.WriteLine("Enter your name:");
userName = Console.ReadLine();
Console.WriteLine($"Welcome {userName}!");
```

Этот код записывает содержимое назначенной переменной userName прямо на экран.
В этом примере вы также читаете два числа. Это немного сложнее, поскольку команда Console.ReadLine() генерирует строку, а вам нужно число. Здесь мы знакомимся с темой преобразования типов, которая более подробно рассматривается в лекции 5, но давайте посмотрим на код, используемый в этом примере.

Сначала вы объявляете переменные, в которых хотите хранить введенные числа:

```cs
double firstNumber, secondNumber;
```

Затем вы считываете ввод и используете команду Convert.ToDouble() для строки, полученной с помощью Console.ReadLine(), чтобы преобразовать строку в тип double. Вы присваиваете этот номер объявленной вами переменной firstNumber:

```cs
Console.WriteLine("Now give me a number:");
firstNumber = Convert.ToDouble(Console.ReadLine());
```
Этот синтаксис удивительно прост, и многие другие преобразования могут быть выполнены аналогичным образом.
Остальная часть кода получает второе число таким же образом:
```cs
Console.WriteLine("Now give me another number:");
secondNumber = Convert.ToDouble(Console.ReadLine());
```
Затем вы выводите результаты сложения, вычитания, умножения и деления двух чисел, а также отображаете остаток после деления, используя оператор остатка (%):
```cs
Console.WriteLine($"The sum of {firstNumber} and {secondNumber} is {firstNumber + secondNumber}.");
Console.WriteLine($"The result of subtracting {secondNumber} from {firstNumber} is {firstNumber - secondNumber}.");
Console.WriteLine($"The product of {firstNumber} and {secondNumber} is {firstNumber * secondNumber}.");
Console.WriteLine($"The result of dividing {firstNumber} by {secondNumber} is {firstNumber / secondNumber}.");
Console.WriteLine($"The remainder after dividing {firstNumber} by {secondNumber} is {firstNumber % secondNumber}.");
```

Обратите внимание, что вы предоставляете выражения firstNumber + SecondNumber и т. д. в качестве параметра оператора Console.WriteLine() без использования промежуточной переменной:
```cs
Console.WriteLine($"The sum of {firstNumber} and {secondNumber} is " +
$"{firstNumber + secondNumber}.");
```
Такой синтаксис может сделать ваш код более читабельным и сократить количество строк кода, которые вам нужно написать.

### Операторы присваивания
До сих пор вы использовали простой оператор присваивания =, и вас может удивить, что вообще существуют какие-либо другие операторы присваивания. Однако есть и другие, и они весьма полезны! Все операторы присваивания, кроме =, работают аналогичным образом. Как и =, все они приводят к присвоению значения переменной в их левой части на основе операндов и операторов в их правой части.

|OPERATOR|CATEGORY|EXAMPLE EXPRESSION|RESULT|
|---|---|---|---|
|=|Binary|var1 = var2;|var1 присваивается значение var2|
|+=|Binary|var1 += var2;|var1 присваивается значение, которое является суммой var1 и var2.|
|-=|Binary|var1 -= var2;|var1 присваивается значение, которое представляет собой значение var2, вычтенное из значения var1.|
|*=|Binary|var1 *= var2;|var1 присваивается значение, которое является произведением var1 и var2.|
|/=|Binary|var1 /= var2;|переменной var1 присваивается значение, которое является результатом деления var1 на var2.|
|%=|Binary|var1 %= var2;|var1 присваивается значение, которое является остатком от деления var1 на var2.|

При выполнении сразу нескольких арифметических операций следует учитывать порядок их выполнения. Приоритет операций от наивысшего к низшему:

- **Инкремент, декремент**

- **Умножение, деление, получение остатка**

- **Сложение, вычитание**

Для изменения порядка следования операций применяются скобки.

## Пространства имен
Прежде чем двигаться дальше, стоит рассмотреть еще одну важную тему — пространства имен. Это способ .NET предоставления контейнеров для кода приложения, позволяющий однозначно идентифицировать код и его содержимое. Пространства имен также используются как средство категоризации элементов в .NET. Большинство из этих элементов представляют собой определения типов, например простые типы, рассмотренные в этой главе (System.Int32 и т. д.).

Код C# по умолчанию содержится в глобальном пространстве имен. Это означает, что элементы, содержащиеся в этом коде, доступны из другого кода в глобальном пространстве имен, просто обращаясь к ним по имени. Однако вы можете использовать ключевое слово namespace, чтобы явно определить пространство имен для блока кода, заключенного в фигурные скобки. Имена в таком пространстве имен должны быть уточнены, если они используются из кода за пределами этого пространства имен.
Полное имя — это имя, содержащее всю иерархическую информацию. Это означает, что если у вас есть код в одном пространстве имен, которому необходимо использовать имя, определенное в другом пространстве имен, вы должны включить ссылку на это пространство имен:

```cs
namespace LevelOne
{
// code in LevelOne namespace
// name "NameOne" defined
}
// code in global namespace
```
Этот код определяет одно пространство имен, LevelOne, и имя в этом пространстве имен, NameOne (здесь не показан фактический код, чтобы обсуждение было общим; вместо этого появляется комментарий, где будет помещено определение). Код, написанный внутри пространства имен LevelOne, может просто ссылаться на это имя с помощью NameOne — классификация не требуется. Однако код в глобальном пространстве имен должен ссылаться на это имя, используя классифицированное имя LevelOne.NameOne.

Обратите внимание еще на один важный момент: оператор using сам по себе не дает вам доступа к именам в другом пространстве имен. Если код в пространстве имен каким-либо образом не связан с вашим проектом, не определен в исходном файле проекта или не определен в каком-либо другом коде, связанном с проектом, у вас не будет доступа к содержащимся в нем именам. Кроме того, если код, содержащий пространство имен, связан с вашим проектом, у вас есть доступ к именам, содержащимся в этом коде, независимо от того, используете ли вы using . Оператор using просто упрощает доступ к этим именам и может сократить длинный код, чтобы сделать его более читабельным.
Возвращаясь к коду ConsoleApp1, показанному в начале этой главы, мы видим следующие строки, относящиеся к пространствам имен:

```cs
using System;
namespace ConsoleApp1
{
    …
}
```
Здесь показаны некоторые другие распространенные пространства имен, например:
```cs
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
```
Строки, начинающиеся с ключевого слова using, используются для объявления того, что пространства имен System, System.Collections.Generic, System.Linq, System.Text и System.Threading.Tasks будут использоваться в этом коде C# и должны быть доступны из всех пространства имен в этом файле без классификации. Пространство имен System является корневым пространством имен для приложений .NET и содержит все основные функции, необходимые для консольных приложений. Остальные четыре пространства имен очень часто используются в консольных приложениях, поэтому они есть на всякий случай. Кроме того, обратите внимание, что для самого кода приложения объявлено пространство имен ConsoleApp1.

C# включает ключевые слова, вызываемые с помощью static . Эти ключевые слова позволяют включать статические члены непосредственно в область программы C#. Например, в обоих пошаговых руководствах по коду  в этой лекции использовался метод System.Console.WriteLine(), который является частью статического класса System.Console. Обратите внимание, что в этих примерах необходимо включить класс Console в сочетании с методом WriteLine(). Когда статическое пространство имен using System.Console добавляется в список включенных пространств имен, для доступа к методу WriteLine() больше не требуется предшествующее имя статического класса.

### Задание
1. Как в следующем коде вы будете обращаться к имени Great из кода в пространстве имен **fabulous** ?
```cs
namespace fabulous
{
    // code in fabulous namespace
}
namespace super
{
    namespace smashing
        {
            // great name defined
        }
}
```
2. Что из перечисленного не является допустимым именем переменной?
   - myVariableIsGood  
   - 99Flake  
   - _floor  
   - time2GetJiggyWidIt  
   - wrox.com
3. Является ли строка «supercalifragilisticexpialidocious» слишком большой, чтобы поместиться в строковую переменную? Если да, то почему?
4. Учитывая приоритет операторов, перечислите шаги, необходимые для вычисления следующего выражения:
```cs
resultVar += var1 * var2 + var3 % var4 / var5;
```
5. Напишите консольное приложение, которое получает от пользователя четыре целочисленных значения и отображает их. Подсказка: возможно, вы помните, что команда Convert.ToDouble() использовалась для преобразования ввода с консоли в double; эквивалентной командой для преобразования строки в целое число является Convert.ToInt32() .




