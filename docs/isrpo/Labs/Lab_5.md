# Лабораторная работа №5. Использование систем сборки Make, CMake, системы сборки для C#.

## Цель работы:
Познакомиться с основами использования систем сборки Make и CMake, научиться создавать Makefile и CMakeLists.txt для сборки проектов на языке C/C++, а также понять различия между этими системами сборки.

## Оборудование и ПО:
- Компьютер с установленной ОС Linux или Windows с поддержкой командной строки.
- Установленные программы: gcc, make, cmake.
- Текстовый редактор (например, VS Code, Sublime Text, Vim).

## Теоретическая часть:

### 1. NMake

NMake — это утилита для сборки проектов, которая входит в состав Visual Studio и предназначена для использования в Windows. Она похожа на GNU Make, но заточена под работу в среде Microsoft. Основным элементом работы NMake является файл `Makefile`, в котором описаны правила сборки, зависимости между файлами и команды для компиляции.

#### Пример структуры Makefile для NMake:
```makefile
# Имя конечного исполняемого файла
TARGET = my_program.exe

# Компилятор и опции компиляции
CC = cl
CFLAGS = /EHsc /W4

# Исходные файлы
SRCS = main.cpp utils.cpp

# Объектные файлы
OBJS = $(SRCS:.cpp=.obj)

# Правило сборки
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) /Fe$(TARGET)

# Правило для объектных файлов
.cpp.obj:
	$(CC) $(CFLAGS) /c $<

# Очистка проекта
clean:
	del $(OBJS) $(TARGET)
```

В данном примере:
- `cl` — компилятор Microsoft C++ (используемый в Visual Studio).
- `CFLAGS` — опции компиляции, такие как включение обработки исключений (`/EHsc`) и уровень предупреждений (`/W4`).
- Правило для сборки исполняемого файла (`$(TARGET): $(OBJS)`) указывает, что файл создается из объектных файлов, и для этого используется компилятор с необходимыми флагами.

### 2. CMake

CMake — это кросс-платформенная система сборки, которая может генерировать файлы проекта для различных сред разработки, включая Visual Studio. CMake используется для создания платформонезависимых сценариев сборки, что особенно полезно при разработке на нескольких ОС. Основным файлом в CMake является `CMakeLists.txt`, в котором описаны инструкции по сборке проекта.

#### Пример структуры CMakeLists.txt:
```cmake
# Минимальная версия CMake
cmake_minimum_required(VERSION 3.10)

# Имя проекта и настройка компиляции
project(MyProgram)

# Установка стандарта C++
set(CMAKE_CXX_STANDARD 17)

# Добавление исходных файлов
set(SOURCES main.cpp utils.cpp)

# Создание исполняемого файла
add_executable(my_program ${SOURCES})
```

В данном примере:
- `cmake_minimum_required(VERSION 3.10)` — указывает минимальную версию CMake, которая требуется для сборки проекта.
- `project(MyProgram)` — задает имя проекта.
- `set(CMAKE_CXX_STANDARD 17)` — указывает, что проект использует стандарт C++17.
- `add_executable(my_program ${SOURCES})` — создает исполняемый файл `my_program.exe` из списка исходных файлов.

### Различия между NMake и CMake

- **Целевая платформа:** NMake предназначен для работы исключительно в среде Windows и тесно интегрирован с Visual Studio, тогда как CMake — это кросс-платформенный инструмент, поддерживающий Windows, Linux, macOS и другие ОС.
- **Гибкость:** CMake предоставляет более гибкие возможности по созданию кросс-платформенных проектов и интеграции с различными средами разработки, включая генерацию проектов для Visual Studio, Makefile, Ninja и других.
- **Поддержка современных стандартов:** CMake активно развивается и поддерживает последние стандарты C++ и инструменты, что делает его предпочтительным выбором для больших проектов, требующих кросс-платформенности.

Эти инструменты имеют свои преимущества и могут использоваться в зависимости от специфики проекта. Например, NMake может быть удобен для небольших Windows-ориентированных проектов, тогда как CMake лучше подходит для кросс-платформенных проектов, требующих гибкости и масштабируемости.

## Практическая часть: Сборка проекта на C++ с использованием NMake и CMake в Windows

### 1. Создание простого проекта на C++

1.1 Создайте директорию для вашего проекта, например, `my_project`.

1.2 Внутри директории создайте три файла: `main.cpp`, `utils.cpp` и `utils.h`.

Пример содержимого `main.cpp`:
```cpp
#include <iostream>
#include "utils.h"

int main() {
    std::cout << "Hello, World!" << std::endl;
    print_utils_message();
    return 0;
}
```

Пример содержимого `utils.cpp`:
```cpp
#include <iostream>
#include "utils.h"

void print_utils_message() {
    std::cout << "This is a message from utils.cpp" << std::endl;
}
```

Пример содержимого `utils.h`:
```cpp
#ifndef UTILS_H
#define UTILS_H

void print_utils_message();

#endif
```

### 2. Создание Makefile для NMake

2.1 В корневой директории вашего проекта создайте файл `Makefile`.

2.2 Впишите в него следующие правила сборки:

```makefile
# Имя конечного исполняемого файла
TARGET = my_program.exe

# Компилятор и опции компиляции
CC = cl
CFLAGS = /EHsc /W4

# Исходные файлы
SRCS = main.cpp utils.cpp

# Объектные файлы
OBJS = $(SRCS:.cpp=.obj)

# Правило сборки
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) /Fe$(TARGET)

# Правило для объектных файлов
.cpp.obj:
	$(CC) $(CFLAGS) /c $<

# Очистка проекта
clean:
	del $(OBJS) $(TARGET)
```

2.3 Откройте командную строку **Developer Command Prompt for Visual Studio**, перейдите в директорию проекта и выполните команду `nmake`, чтобы собрать проект. Исполняемый файл `my_program.exe` должен быть создан в текущей директории.

2.4 Запустите полученный исполняемый файл, выполнив в командной строке `my_program.exe`, и убедитесь, что программа работает корректно.

### 3. Создание CMakeLists.txt

3.1 В корневой директории вашего проекта создайте файл `CMakeLists.txt`.

3.2 Заполните его следующим содержимым:

```cmake
# Минимальная версия CMake
cmake_minimum_required(VERSION 3.10)

# Имя проекта и настройка компиляции
project(MyProgram)

# Установка стандарта C++
set(CMAKE_CXX_STANDARD 17)

# Добавление исходных файлов
set(SOURCES main.cpp utils.cpp)

# Создание исполняемого файла
add_executable(my_program ${SOURCES})
```

3.3 Создайте поддиректорию `build` и перейдите в неё:

```cmd
mkdir build
cd build
```

3.4 Выполните команду `cmake ..`, чтобы сгенерировать проект для Visual Studio.

3.5 Выполните команду `cmake --build .`, чтобы собрать проект. Исполняемый файл `my_program.exe` должен быть создан в поддиректории `build`.

3.6 Запустите полученный исполняемый файл, выполнив в командной строке `my_program.exe`, и убедитесь, что программа работает корректно.

### 4. Сравнение NMake и CMake

4.1 Ответьте на следующие вопросы:
- В чем различие в подходе к сборке между NMake и CMake в Windows?
- Какие преимущества и недостатки каждой из систем вы заметили?
- В каких случаях вы бы предпочли использовать NMake, а в каких CMake?

### 5. Дополнительное задание (по желанию)

5.1 Попробуйте изменить проект таким образом, чтобы каждый файл находился в своей поддиректории (например, `src` для исходников и `include` для заголовочных файлов).

5.2 Настройте Makefile и CMakeLists.txt так, чтобы они корректно работали с новой структурой проекта.

## Системы cборки для C#

### Введение
Система сборки — это набор инструментов и методов, используемых для автоматизации процесса создания программного обеспечения. Для языка программирования C# наиболее распространенными системами сборки являются **MSBuild** (Microsoft Build Engine) и **.NET CLI** (командная строка для .NET Core и .NET 5+). Эти системы позволяют автоматически компилировать код, управлять зависимостями, выполнять тесты и собирать конечные артефакты (например, исполняемые файлы или библиотеки).

### MSBuild
MSBuild (Microsoft Build Engine) — это основная система сборки, используемая в экосистеме .NET. Она может управлять всем процессом сборки, начиная с компиляции кода и заканчивая упаковкой и развертыванием приложений.

**Основные компоненты MSBuild:**
1. **Проекты (Project):** Основная единица сборки, представленная XML-файлом с расширением `.csproj`. Этот файл определяет структуру проекта, включенные файлы, параметры компиляции и зависимости.
2. **Задачи (Tasks):** Минимальные действия, выполняемые MSBuild. Примеры задач включают компиляцию кода, копирование файлов, выполнение тестов.
3. **Цели (Targets):** Группы задач, которые выполняются для достижения определенных целей. Например, цель `Build` может включать задачи для компиляции кода, создания документации и упаковки приложения.
4. **Условные сборки:** MSBuild поддерживает условные сборки, что позволяет управлять разными конфигурациями (например, Debug и Release) с использованием условных операторов в файле проекта.

**Пример файла проекта (.csproj):**
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <RootNamespace>MyApp</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>
</Project>
```

### .NET CLI
.NET CLI (Command-Line Interface) — это инструмент командной строки, используемый для работы с проектами .NET. .NET CLI позволяет разрабатывать, компилировать, тестировать и развертывать приложения на базе .NET.

**Основные команды .NET CLI:**
1. `dotnet new`: Создание нового проекта.
2. `dotnet build`: Компиляция проекта.
3. `dotnet run`: Запуск приложения.
4. `dotnet test`: Запуск тестов.
5. `dotnet publish`: Публикация приложения, создание артефакта для развертывания.

**Пример использования .NET CLI:**
```bash
dotnet new console -n MyApp
cd MyApp
dotnet add package Newtonsoft.Json
dotnet build
dotnet run
```

### Пример: Разработка и Сборка Консольного Приложения
1. Создание нового консольного приложения:
   ```bash
   dotnet new console -n HelloWorld
   ```
2. Переход в директорию проекта:
   ```bash
   cd HelloWorld
   ```
3. Добавление зависимости:
   ```bash
   dotnet add package Newtonsoft.Json
   ```
4. Компиляция и запуск проекта:
   ```bash
   dotnet build
   dotnet run
   ```
5. Публикация приложения для развертывания:
   ```bash
   dotnet publish -c Release -r win-x64
   ```

### Заключение
Системы сборки, такие как MSBuild и .NET CLI, являются неотъемлемой частью процесса разработки на C#. Они обеспечивают автоматизацию различных этапов создания программного обеспечения, включая компиляцию, управление зависимостями, тестирование и упаковку. Грамотное использование этих инструментов позволяет разработчикам существенно повысить продуктивность и надежность процесса разработки.

## Индивидуальное задание Make/Cmake

1.	Разделить исходный текст программы из лабораторной работы №4 на два cpp-файла; для этого переместить в отдельный файл часть классов или функций, определенных в программе (если программа состоит из единственной функции main, разбить ее на две функции).

2.	Написать makefile для сборки программы утилитой NMAKE.EXE, используя справочные сведения https://msdn.microsoft.com/ru-ru/library/dd9y37ha.aspx (там, в частности, приводится образец makefile, см. https://msdn.microsoft.com/ru-ru/library/x6bt6xe7.aspx)

3.	Убедиться в работоспособности makefile:
    - собрать программу утилитой NMAKE.EXE
    - изменить один из файлов и пересобрать программу – второй файл при этом перекомпилироваться не должен
4.	Модифицируйте makefile так, чтобы в нем было две цели:
    - debug – компиляция программы в каталог /debug, с отладочной информацией и без оптимизации
    - release – компиляция программы в каталог /release, без отладочной информации и с оптимизацией по скорости /O2

5.	Скачайте и распакуйте утилиту CMake для Вашей ОС с https://cmake.org/download/ (используйте zip-версию дистрибутива, а не msi, т.к. она не требует установки).

6.	Создайте файл CMakeLists.txt по следующему образцу (во второй строке следует перечислить файлы вашей программы):
```cmake
PROJECT (Lab04)
SET (PROJECT_SOURCE_LIST main.cpp other.cpp)
ADD_EXECUTABLE(Lab04 ${PROJECT_SOURCE_LIST})
```

7.	Используя версию CMAKE с графическим интерфейсом cmake-gui.exe (или консольную версию cmake.exe) сгенерируйте файлы проектов:
    - для вашей версии Visual Studio в каталоге /build_vs
    - для утилиты NMAKE в каталоге /build_namake (прим.: для этого CMAKE нужно запускать из окружения Visual Studio Command Prompt (vcvarsall.bat))

8.	Проверьте работоспособность полученных проектов.

9.	Изучите makefile, созданный CMAKE для NAMKE-проекта. Сделайте выводы, какие цели он содержит и чем отличается от вашего makefile.

## Индивидуальные задания MSBuild

### Вариант 1
Создайте проект на C# с использованием .NET CLI, который принимает строку JSON и преобразует её в объект. Добавьте необходимые зависимости, используя `dotnet add package`. Опишите процесс сборки и публикации проекта, подготовив его для развертывания на Windows.

### Вариант 2
Разработайте консольное приложение на C# с использованием MSBuild, которое читает данные из файла и выводит их на экран. Реализуйте условную сборку для конфигураций Debug и Release, где в Debug будет выводиться дополнительная информация (например, отладочные сообщения).

### Вариант 3
Создайте библиотеку классов на C# с помощью .NET CLI. Реализуйте несколько классов, обеспечивающих базовую работу с коллекциями данных. Настройте автоматическое тестирование библиотеки с использованием `dotnet test` и опишите процесс сборки проекта.

### Вариант 4
Разработайте проект с использованием MSBuild, который включает в себя несколько целей (Targets), например, для компиляции, тестирования и упаковки. Определите свои собственные задачи (Tasks) и продемонстрируйте их использование в процессе сборки.

### Вариант 5
Создайте веб-приложение на C# с использованием ASP.NET Core и .NET CLI. Добавьте внешние зависимости и настройте скрипт сборки и публикации приложения, который будет включать команды для сборки, тестирования и развертывания. Подготовьте инструкцию по сборке проекта на другом компьютере с использованием командной строки.

## Отчет по лабораторной работе:

Отчет должен содержать:
1. Тему работы.
2. Цель работы.
3. Краткое описание теоретической части.
4. Код исходных файлов `main.c`, `utils.c`, `utils.h`.
5. Полный текст Makefile и CMakeLists.txt.
6. Скриншоты успешной сборки и запуска программы для обоих случаев.
7. Выполнение задания по MSBuild
8. Ответы на вопросы из пункта 4.1.
9. Заключение, в котором подведены итоги работы и сформулированы основные выводы.

## Вопросы для самопроверки:
1. Какой файл используется Make для управления сборкой проекта?
2. Какой файл используется CMake для тех же целей?
3. Что делает команда `cmake ..`?
4. В чем основное различие между Make и CMake?

## Заключение:
В ходе данной лабораторной работы вы освоили основы использования систем сборки Make, CMake, MSBuild. Научились создавать необходимые файлы конфигурации и строить простые проекты. Вы также познакомились с различиями и особенностями этих систем, что позволит вам в будущем выбирать наиболее подходящий инструмент для ваших задач.